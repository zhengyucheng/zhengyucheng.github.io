---
layout:     post
title:      "201904"
subtitle:   ""
date:       2019-04-02
author:     "JU"
header-img: "img/post-bg-2015.jpg"
mathjax:    true
catalog:    true
tags:
    - test
---

## smoj520

### P1

 $\text{yy}$ 一下可以发现,最优策略肯定是:  

 $\text{1.}$ 在一个区间反复横跳  

 $\text{2.}$ 向右换一个区间  

 $\text{3.}$ 重复 $\text{1,2}$   

因为切换区间时经过的权值和肯定是负的,所以如果不按上述策略,则会导致重复经过这些负的区间.  

于是  $\text{dp}$ :  

 $sum$ :区间权值和  

 $s[i]$ :以 $\text{i}$ 结尾的最大权值后缀和  

 $f[i]$ :到达 $\text{i}$ 位置时所用最小移动次数  

 $g[i]$ :在满足 $f$ 的同时,能获得的最大权值  

```cpp
#include <cstdio>
#include <cstring>
#include <algorithm>
#include <cstring>
#include <string>
#include <cstdlib>
#include <queue>
#include <cmath>
#define pr(p) printf("%lld\n",p)
const long long oo=1000000000000000000;
const int N=110;
const int mod=1000000007;
using namespace std;
typedef long long LL;
typedef double db;
inline void sc (LL &x)
{
    x=0; static int p; p=1; static char c; c=getchar();
    while (!isdigit(c)) { if (c=='-') p=-1; c=getchar(); }
    while ( isdigit(c)) { x=(x<<1)+(x<<3)+(c-48); c=getchar(); }
    x*=p;
}
LL up (LL A,LL B) { return (LL)(A/B)+!!(A%B); }
LL a[N],sum[N][N],w[N],s[N],f[N],g[N];
int main()
{
	// freopen ("2843.in","r",stdin);
	// freopen ("2843.out","w",stdout);
	LL T; sc(T);
	while (T--)
	{
		LL n,k; sc(n),sc(k);
		for (int i=1; i<=n; i++)
			sc(a[i]);
		for (int i=1; i<=n; i++)
			for (int j=i; j<=n; j++)
				sum[i][j]=sum[i][j-1]+a[j];
		for (int i=1; i<=n; i++)
		{
			s[i]=-oo;
			for (int j=1; j<=i; j++)
				if (sum[j][i]> s[i]) s[i]=sum[j][i];
		}
		f[1]=1,g[1]=a[1];
		LL ans=max (0LL,(k-f[1])*s[1]+g[1]);
		for (int i=2; i<=n; i++)
		{
			f[i]=oo,g[i]=-oo;
			for (int j=1; j< i; j++)
			{
				LL s1=sum[j+1][i],c=0;
				if (s1+g[j]< 0)
				{
					if (s[j]> 0) c=up (-(s1+g[j]),s[j]*2)*2;
					else continue;
				}
				if (f[j]+c> k) continue;
				if (f[j]+c==f[i]) g[i]=max (g[i],g[j]+c*s[j]+s1);
				if (f[j]+c< f[i]) f[i]=f[j]+c,g[i]=g[j]+c*s[j]+s1;
			}
			if (g[i]>=0&&f[i]<=k) ans=max (ans,(k-f[i])*s[i]+g[i]);
		}
		pr(ans);
	}
	
	return 0;
}

```

### P2

 $\text{yy}$ 一下:

 $\text{1.}$ $F$ 和 $S$ 的数量尽量接近

 $\text{2.}$ $F+S$ 最大不会超过 $\lceil\sqrt{n}\rceil$

 于是硬核模拟:  

 $\text{1.}$ 当当前金币数 $\text{>=price}$ ,且雇佣更多人更优,就不断增加 $\text{F,S}$ 中较小的一个  

 $\text{2.}$ 否则一次性增加到金币数 $\text{>=price}$   


	#include <cstdio>
	#include <cstring>
	#include <algorithm>
	#include <cstring>
	#include <string>
	#include <cstdlib>
	#include <queue>
	#include <cmath>
	const int oo=2139063143;
	const int N=1010000;
	const int mod=1000000007;
	using namespace std;
	typedef __int128 LL;
	typedef double db;
	inline void sc (LL &x)
	{
	    x=0; static int p; p=1; static char c; c=getchar();
	    while (!isdigit(c)) { if (c=='-') p=-1; c=getchar(); }
	    while ( isdigit(c)) { x=(x<<1)+(x<<3)+(c-48); c=getchar(); }
	    x*=p;
	}
	inline void pr(LL x)
	{
	    if (x< 0)
	    {
		putchar('-');
		x=-x;
	    }
	    if (x> 9) pr(x/10);
	    putchar(x%10+'0');
	}
	LL up (LL A,LL B) { return (LL)(A/B)+!!(A%B); }
	int main()
	{
		// freopen ("2844.in","r",stdin);
		// freopen ("2844.out","w",stdout);
		LL T; sc(T);
		while (T--)
		{
			LL a,b,p,s; sc(a),sc(b),sc(p),sc(s);
			if (a< b) swap (a,b);
			if (1LL*a*b> s) { pr(1LL); continue; }
			LL ans=up (s,a*b),cur=0,sum=0;
			bool fg=0;
			while (1)
			{
				while (sum>=p)
				{
					LL g1=up (s-sum,a*b),g2=up (s-sum+p,a*(b+1));
					if (cur+min (g1,g2)> ans) { fg=1; break; }
					ans=cur+min (g1,g2);
					if (g2> g1) { fg=1; break; }
					++b;
					sum-=p;
					if (a< b) swap (a,b);
					if (b>=1000000) { fg=1; break; }
				}
				if (fg) break;
				if (sum>=s) break;
				LL q=up (p-sum,a*b);
				sum+=q*a*b;
				cur+=q;
			}
			pr(ans);
		}

		return 0;
	}


### P3

 $\text{dp}$   

 $f[i]$ 表示桌上有  $\text{i}$ 个,手上有 $\text{1}$ 个时,距离游戏结束剩余轮数的期望  

易得 $f[0]=f[2*n]=0$   

所求的为 $f[n]$   

转移:

$$
f[i]=\frac{1}{2}(f[i+1]+1)+\sum_{j=2}^{ma}\frac{1}{2^j}(f[i-2^{j-1}+2]+j)+\frac{ma}{2^{ma}}
$$

有 $\frac{1}{2^j}$ 的概率进行 $j-1$ 次操作二,再进行一次操作一.  

设

$$
s=\sum_{j=2}^{ma}\frac{1}{2^j}(f[i-2^{j-1}+2]+j)
$$

则

$$
\frac{1}{2}(f[i+1]+1)=f[i]-s-\frac{ma}{2^{ma}}
$$

化简后

$$
f[i+1]=2(f[i]-s-\frac{ma}{2^{ma}})+1
$$

其中

$$
ma=\log_{2}{i}+1
$$

可以发现,每个 $f[i]$ 都是 $\sum_{j=0}^{i-1}a[j]*f[j]+B$ ,所有用到的未知数( $f$ )都是一次项.  

而且,还可以知道,当 $f[1]$ 确定,所有的 $f$ 都确定了.  

有一个问题,可能当 $f[1]=x$ 时, $f[n*2]!=0$.  

可以设每个 $ f[i]=a_i*x+b_i $ ,转移到 $f[n*2]$ 后算出 $x$ (就是 $f[1]$ ),再计算 $f[n]$ 即可.

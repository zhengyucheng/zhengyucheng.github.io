---
layout:     post
title:      "整体二分"
subtitle:   "二分"
date:       2018-05-27
author:     "JU"
header-img: "img/post-bg-2015.jpg"
mathjax:    false
catalog:    true
tags:
    - 二分
---

整体二分是将所有操作（含询问）放在一起处理，二分的是答案
### 例题1
单点修改，询问区间第K小，可离线。  
首先，把所有修改变成删除一个数与插入一个数。  
对所有区间进行二分，二分答案mid。  
遇到修改，若修改的数`≤mid`，才进行修改，并归入`S1`,否则归入`S2`。 
遇到查询，则查询当前区间中数的个数，若≥K,说明答案在`[L,mid]`内，归入`S1`，否则归入`S2`。 
使用树状数组维护。  
http://acm.hdu.edu.cn/showproblem.php?pid=5412

      #include <bits/stdc++.h>
      using namespace std;
      #define sc(p) scanf("%d",&p)
      #define pr(p) printf("%d",p)
      const int N=500100;
      const int oo=0x7FFFFFFF;
      struct DATA
      {
        int op,id,x,y,k,cnt;
      }s[N],t1[N],t2[N]; int ma,cao,q;
      void addata (int op,int id,int x,int y,int k)
      { ++cao; s[cao].op=op,s[cao].id=id,s[cao].x=x,s[cao].y=y,s[cao].k=k,s[cao].cnt=0; }
      int bit[N+100]; int n;
      int lowbit (int x) { return x&-x; }
      int flag[N];
      void add (int x,int d,int id)  //小技巧：相当于清空bit(flag) 
      {
        for (int i=x; i<=n; i+=lowbit(i))
        {
          if (flag[i]!=id) flag[i]=id,bit[i]=0;
          bit[i]+=d;
        }
      }
      int sum (int x,int id)
      {
        int sb=0;
        for (int i=x; i; i-=lowbit(i))
        if (flag[i]==id) sb+=bit[i];
        return sb;
      }
      int val[N],ans[N],tmp[N];
      int DFN=0;
      void solve (int L,int R,int l,int r)
      {
        if(L>R) return ;
        if(l==r)
        {
          for(int i=L; i<=R; i++)
          if(s[i].op==3) ans[s[i].id]=l;
          return ;
        }
        memset (bit,0,sizeof (bit));
        int mid=(l+r)/2; ++DFN;
        for (int i=L; i<=R; i++)
        {
          if (s[i].op==1&&s[i].y<=mid) add (s[i].x,1,DFN);
          if (s[i].op==2&&s[i].y<=mid) add (s[i].x,-1,DFN);
          if (s[i].op==3) tmp[i]=sum (s[i].y,DFN)-sum (s[i].x-1,DFN);
        }
        int g1=0,g2=0;
        for (int i=L; i<=R; i++)
        if (s[i].op==3)
        {
          if (s[i].cnt+tmp[i]>=s[i].k) t1[++g1]=s[i];
          else s[i].cnt+=tmp[i],t2[++g2]=s[i];
        }
        else
        {
          if (s[i].y<=mid) t1[++g1]=s[i];
          else t2[++g2]=s[i];
        }
        for (int i=1; i<=g1; i++) s[L+i-1]=t1[i];
        for (int i=1; i<=g2; i++) s[L+g1+i-1]=t2[i];
        solve (L,L+g1-1,l,mid);
        solve (L+g1,R,mid+1,r);
      }
      int main()
      {
        //freopen (".in","r",stdin);
        //freopen (".out","w",stdout);
        int sum;
        while(~scanf("%d",&n))
        {
          memset (bit,0,sizeof (bit));
          memset (flag,0,sizeof (flag));
          sum=ma=cao=q=DFN=0;
          for (int i=1; i<=n; i++)
          {
            sc(val[i]);
            addata (1,-1,i,val[i],-1);
            ma=max (ma,val[i]);
          }
          int Q; sc(Q);
          for (int i=1; i<=Q; i++)
          {
            int op,x,y,k; sc(op),sc(x),sc(y);
            if (op==1)
            {
              addata (2,-1,x,val[x],-1);
              addata (1,-1,x,y,-1);
              ma=max (ma,y);
              val[x]=y;
            }
            else
            {
              q++; sc(k);
              addata (3,q,x,y,k);
              s[cao].cnt=0;
            }
          }
          solve (1,cao,0,ma);
          for (int i=1; i<=q; i++) printf ("%d\n",ans[i]);
        }
        return 0;
      }
  
### 例题2
然而还有更强的：luoguP3332  
类似方法：

    #include <bits/stdc++.h>
    using namespace std;
    #define sc(p) scanf("%d",&p)
    #define pr(p) printf("%d",p)
    #define LL long long
    const int N=100100;
    const int oo=0x7FFFFFFF;
    struct LGJ {int id,pos,l,r; LL k;}p[N],p1[N],p2[N];
    int ans[N];
    LL bit1[N],bit2[N];
    int n,cnt=0;
    void add (int x,LL d) { for (int i=x; i<=n; i+=i&-i) bit1[i]+=d,bit2[i]+=x*d; }
    LL sum (int x) { LL sb=0; for (int i=x; i; i-=i&-i) sb+=(x+1)*bit1[i]-bit2[i]; return sb; }
    void solve (int L,int R,LL l,LL r)
    {
      if (L>R) return ;
      if (l==r)
      {
        for (int i=L; i<=R; i++)
        if (p[i].pos==2) ans[p[i].id]=l;
        return ;
      }

      LL mid=(l+r)/2; int s1=0,s2=0;
      for (int i=L; i<=R; i++)
      {
        if (p[i].pos==1)
          if (p[i].k<=mid)
          {
            add (p[i].l,1),add (p[i].r+1,-1);
            p1[++s1]=p[i];
          }
          else p2[++s2]=p[i];
        else
        {
          LL g=sum (p[i].r)-sum(p[i].l-1);
          if (g>=p[i].k) p1[++s1]=p[i];
          else p[i].k-=g,p2[++s2]=p[i];
        }
      }

      for (int i=L; i<=R; i++)
      if (p[i].pos==1&&p[i].k<=mid)
      add (p[i].l,-1),add (p[i].r+1,1);

      for(int i=1;i<=s1;i++) p[i+L-1]=p1[i];
      for(int i=1;i<=s2;i++) p[i+L+s1-1]=p2[i];
      if(s1) solve(L,L+s1-1,l,mid);
      if(s2) solve(L+s1,R,mid+1,r);
    }
    int main()
    {
      //freopen (".in","r",stdin);
      //freopen (".out","w",stdout);
      int m;
      sc(n),sc(m);
      for (int i=1; i<=m; i++)
      {
        scanf ("%d%d%d%lld",&p[i].pos,&p[i].l,&p[i].r,&p[i].k);
        if (p[i].pos==1) p[i].k=n-p[i].k+1;
        else p[i].id=++cnt;
      }
      solve (1,m,0,(LL)n*2+2);
      for (int i=1; i<=cnt; i++)
      printf ("%lld\n",(LL)n-ans[i]+1);
      return 0;
    }

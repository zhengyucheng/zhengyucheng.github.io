---
layout:     post
title:      "斜率优化"
subtitle:   "只凸不凹"
date:       2018-07-20
author:     "JU"
header-img: "img/post-bg-2015.jpg"
mathjax:    false
catalog:    true
tags:
    - DP
---

### Luogu2900

    #include <bits/stdc++.h>
    #define sc(p) scanf("%lld",&p)
    #define sc2(p1,p2) scanf("%lld%lld",&p1,&p2)
    #define sc3(p1,p2,p3) scanf("%d%d%d",&p1,&p2,&p3)
    #define pr(p) printf("%d\n",p)
    const int oo=2147483640;
    const int N=1010000;
    const int mod=1000000007;
    using namespace std;
    struct MUD { long long h,w; }sb[N];
    bool ly (MUD A,MUD B) { return A.h>B.h; }
    long long x[N],y[N],f[N];
    long long q[N],head,tail;
    #define j1 q[head]
    #define j2 q[head+1]
    #define jj1 i
    #define jj2 q[tail-1]
    #define jj3 q[tail-2]
    int main()
    {
        //freopen(".in","r",stdin);
        //freopen(".out","w",stdout);
        long long n; sc(n);
        for (int i=1; i<=n; i++) sc2(sb[i].h,sb[i].w);
        sort (sb+1,sb+n+1,ly);
        int ma=0,tot=0;
        for (int i=1; i<=n; i++)
        {
            if (sb[i].w<=ma) continue;
            x[++tot]=sb[i].w; y[tot]=sb[i].h;
            ma=x[tot];
        }
        n=tot;
        q[0]=0,head=0,tail=1;
        for (int i=1; i<=n; i++)
        {

            while (head+1<tail&& f[j2]-f[j1] <= x[i]*(y[j1+1]-y[j2+1]))
            head++;
            f[i]=f[j1]+x[i]*y[j1+1];
            while (head+1<tail&& (f[jj2]-f[jj1])*(y[jj2+1]-y[jj3+1]) <= 
                                 (f[jj3]-f[jj2])*(y[jj1+1]-y[jj2+1])) tail--;
            q[tail++]=i;
            //cout<<f[i]<<" "; 
        }
        cout<<f[n];
        return 0;
    }


## 斜率优化
### 概念
用于优化形如`f[i]=max{f[j]+g[i]*x[j]+t[j]+h[i]}`的`DP`转移方程。
### BZOJ3437




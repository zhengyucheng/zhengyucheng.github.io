---
layout:     post
title:      "可持久化"
subtitle:   "数据结构"
date:       2018-05-13
author:     "JU"
header-img: "img/post-bg-2015.jpg"
mathjax:    false
catalog:    true
tags:
    - 可持久化
---

## 可持久化线段树
话说线段树大家应该都听说过，然而加上了“可持久化”四个大字后有什么区别呢？？
#### 概念
我们知道，每次单点修改，都需要更新约`logn`个线段树上的节点。  
而线段树XL（指代可持久化）与普通线段树最大的区别在于，每次要修改一个数据时，不在原线段树上修改，而是在受到影响的节点“旁边”新建一个节点，上面记录新的数据。  
而这些新建的节点与不受影响的节点，构成了一个历史版本。
同时，不再使用普通线段树的节点编号方式，而是根据新建节点的顺序进行编号，节约空间。这样，就需要额外记录每个节点的两个儿子的编号。  
当然，每个版本的根节点最好额外记录一下。
### 模板题 luoguP3834
看到这题，就连傻子也知道要用可持久化线段树来做……（标题写着呢）  
#### 思路
回到本题，首先依次插入序列中的每个数的**排名**，这样就得到了`n`个历史版本（类似前缀和的东西）。  
每次询问一个区间，就调出第`l-1`与第`r`个历史版本，将其对应的节点相减，即可得知所需的信息。  
当然，不是每个点都相减，而只是相关点。  
最后进行一些细节处理即可。

        #include <bits/stdc++.h>
        #define sc(p) scanf("%d",&p)
        using namespace std;
        const int N=200100;
        struct LGJ
        {
            int id,pm,num;
        }a[N];
        bool LGJ1 (LGJ q1,LGJ q2) { return q1.num<q2.num; }
        bool LGJ2 (LGJ q1,LGJ q2) { return q1.id<q2.id; }
        struct TREEXL
        {
            int sum,ls,rs;
            #define ls(p) t[p].ls
            #define rs(p) t[p].rs
            #define sum(p) t[p].sum
        }t[N*20];
        int n,m;
        int tot=0,root[N]={0};
        int rea[N];
        int build (int l,int r)
        {
            int p=++tot;
            if (l<r)
            {
                int mid=(l+r)/2;
                ls(p)=build (l,mid);
                rs(p)=build (mid+1,r);
            }
            return p;
        }
        int insert (int old,int l,int r,int x)
        {
            int p=++tot;
            ls(p)=ls(old),rs(p)=rs(old),sum(p)=sum(old)+1;
            if (l<r)
            {
                int mid=(l+r)/2;
                if (x<=mid) ls(p)=insert (ls(old),l,mid,x);
                else rs(p)=insert (rs(old),mid+1,r,x);
            }
            return p;
        }
        int search (int pre,int aft,int l,int r,int k)
        {
            if (l==r)  return l;
            int x=sum(ls(aft))-sum(ls(pre));
            int mid=(l+r)/2;
            if (x>=k) return search (ls(pre),ls(aft),l,mid,k);
            else return search (rs(pre),rs(aft),mid+1,r,k-x);
        }
        int b[N];
        int main()
        {
            //freopen ("data.out","r",stdin);
            //freopen ("mine.out","w",stdout);
            sc(n),sc(m);
            for (int i=1; i<=n; i++) sc(a[i].num),a[i].id=i;

            sort (a+1,a+n+1,LGJ1);
            int sum=0;
            for (int i=1; i<=n; i++)
            {
                if (i==1||a[i].num!=a[i-1].num) a[i].pm=++sum;
                else a[i].pm=sum;
                b[a[i].pm]=a[i].num;
            }
            sort (a+1,a+n+1,LGJ2);

            root[0]=build (1,sum);
            for (int i=1; i<=n; i++)
            root[i]=insert (root[i-1],1,sum,a[i].pm);

            for (int i=1; i<=m; i++)
            {
                int x,y,k; sc(x),sc(y),sc(k);
                printf ("%d\n",b[search (root[x-1],root[y],1,sum,k)]);
            }
            return 0;
        }

## 可持久化Trie
线段树XL如此腻害，相信TrieXL也能在处理字符串上所向披靡吧~~
### 例题：SMOJ2505
#### 思路
等等，不是说处理字符串吗？！咋变成数了！？没事，注意到xor运算，于是应想到将其二进制按位分解。而能够储存这些二进制形式的最佳数据结构，莫过于Trie。（虽然比赛时完全没想到）  
而数据又有一个奇怪之处：n<=1000,m<=300000，这明显暗示处理行时暴力，处理列时用特殊方法。  
#### 做法
于是构建一棵可持久化Trie，依次将给出的Y[]插入（**从高位到低位**），并记录root[]；同时，记录当前节点的路径是多少个数（二进制）的前缀。  

    bool check (int a,int w)
    {
        return (a&(1<<(w-1)));
    }
    int L[N],R[N];
    void insert (int w,int old,int &now,int v)
    {
        now=++tot;
        ls(now)=ls(old),rs(now)=rs(old);
        cnt(now)=cnt(old)+1;
        if (w==0) return ;
        if (check (v,w)) 
            insert (w-1,rs(old),rs(now),v);
        else 
            insert (w-1,ls(old),ls(now),v);
    }
    
每次读入一个询问，就调出区间`[l,r]`的信息`L[]`、`R[]`（实际上只是调出`root[l-1]`与`root[r]`），进行查询。  

1.为方便处理，首先将“第`k`大”转变为”第（`（矩形大小）-k+1`）小“（改变`k`）。 

2.由Tire从高位到低位插入易知，当某行的`w`位（二进制）为`0/1`时，将`Tire`上当前节点的`leftson`（0在左）/`rightson`的数量累加起来，由于当前位相同，异或的结果也最小，由得到的结果`sum`可知矩形内前`sum`小的数的信息（如在哪个儿子内）。  

    int sum=0;
	for (int i=u; i<=d; i++)
		if (check (x[i],w)) 
			sum+=cnt(rs(R[i]))-cnt(rs(L[i]));
		else 
			sum+=cnt(ls(R[i]))-cnt(ls(L[i]));

3.由此可以分类讨论：  
  1）sum<k。此时所有L[]R[]都移向能使sum增大的儿子处，并使k减小sum。同时由于返回的是最终答案（一个值，而非一个位置），应加上2^（？？）。这样做是因为由于移向了异或后的结果为1的位置，而除去了当前这一位，要在答案中补上。  

  2）sum>k。同样将LR移向使sum减小的儿子。此时由于移向异或结果为0的儿子，这一位对答案无影响，无需加2^（？？）。  
  
	if (sum<k)
	{	
		for (int i=u; i<=d; i++)
			if (check (x[i],w)) 
				L[i]=ls(L[i]),R[i]=ls(R[i]); 
			else 
				L[i]=rs(L[i]),R[i]=rs(R[i]); 

		return query (w-1,k-sum,u,d)+(1<<(w-1));
	}
	else
	{
		for (int i=u; i<=d; i++)
			if (check (x[i],w)) 
				L[i]=rs(L[i]),R[i]=rs(R[i]);
		else 
			L[i]=ls(L[i]),R[i]=ls(R[i]);

		return query (w-1,k,u,d);
	}

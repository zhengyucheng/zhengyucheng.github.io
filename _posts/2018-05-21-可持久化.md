---
layout:     post
title:      "可持久化"
subtitle:   "数据结构"
date:       2018-05-13
author:     "JU"
header-img: "img/post-bg-2015.jpg"
mathjax:    false
catalog:    true
tags:
    - 可持久化
---

## 可持久化线段树
话说线段树大家应该都听说过，然而加上了“可持久化”四个大字后有什么区别呢？？
### 模板题 luoguP3834
看到这题，就连傻子也知道要用可持久化线段树来做……（标题写着呢）  
我们知道，每次单点修改，都需要更新约`logn`个线段树上的节点。  
而线段树XL（指代可持久化）与普通线段树最大的区别在于，每次要修改一个数据时，不在原线段树上修改，而是在受到影响的节点“旁边”新建一个节点，上面记录新的数据。  
而这些新建的节点与不受影响的节点，构成了一个历史版本。
同时，不再使用普通线段树的节点编号方式，而是根据新建节点的顺序进行编号，节约空间。这样，就需要额外记录每个节点的两个儿子的编号。  
当然，每个版本的根节点最好额外记录一下。

---

回到本题，首先依次插入序列中的每个数的**排名**，这样就得到了`n`个历史版本（类似前缀和的东西）。  
每次询问一个区间，就调出第`l-1`与第`r`个历史版本，将其对应的节点相减，即可得知所需的信息。  
当然，不是每个点都相减，而只是相关点。  
最后进行一些细节处理即可。

        #include <bits/stdc++.h>
        #define sc(p) scanf("%d",&p)
        using namespace std;
        const int N=200100;
        struct LGJ
        {
            int id,pm,num;
        }a[N];
        bool LGJ1 (LGJ q1,LGJ q2) { return q1.num<q2.num; }
        bool LGJ2 (LGJ q1,LGJ q2) { return q1.id<q2.id; }
        struct TREEXL
        {
            int sum,ls,rs;
            #define ls(p) t[p].ls
            #define rs(p) t[p].rs
            #define sum(p) t[p].sum
        }t[N*20];
        int n,m;
        int tot=0,root[N]={0};
        int rea[N];
        int build (int l,int r)
        {
            int p=++tot;
            if (l<r)
            {
                int mid=(l+r)/2;
                ls(p)=build (l,mid);
                rs(p)=build (mid+1,r);
            }
            return p;
        }
        int insert (int old,int l,int r,int x)
        {
            int p=++tot;
            ls(p)=ls(old),rs(p)=rs(old),sum(p)=sum(old)+1;
            if (l<r)
            {
                int mid=(l+r)/2;
                if (x<=mid) ls(p)=insert (ls(old),l,mid,x);
                else rs(p)=insert (rs(old),mid+1,r,x);
            }
            return p;
        }
        int search (int pre,int aft,int l,int r,int k)
        {
            if (l==r)  return l;
            int x=sum(ls(aft))-sum(ls(pre));
            int mid=(l+r)/2;
            if (x>=k) return search (ls(pre),ls(aft),l,mid,k);
            else return search (rs(pre),rs(aft),mid+1,r,k-x);
        }
        int b[N];
        int main()
        {
            //freopen ("data.out","r",stdin);
            //freopen ("mine.out","w",stdout);
            sc(n),sc(m);
            for (int i=1; i<=n; i++) sc(a[i].num),a[i].id=i;

            sort (a+1,a+n+1,LGJ1);
            int sum=0;
            for (int i=1; i<=n; i++)
            {
                if (i==1||a[i].num!=a[i-1].num) a[i].pm=++sum;
                else a[i].pm=sum;
                b[a[i].pm]=a[i].num;
            }
            sort (a+1,a+n+1,LGJ2);

            root[0]=build (1,sum);
            for (int i=1; i<=n; i++)
            root[i]=insert (root[i-1],1,sum,a[i].pm);

            for (int i=1; i<=m; i++)
            {
                int x,y,k; sc(x),sc(y),sc(k);
                printf ("%d\n",b[search (root[x-1],root[y],1,sum,k)]);
            }
            return 0;
        }

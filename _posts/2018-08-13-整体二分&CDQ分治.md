---
layout:     post
title:      "整体二分&CDQ分治"
subtitle:   "我永远喜欢LZZ"
date:       2018-08-13
author:     "JU"
header-img: "img/post-bg-2015.jpg"
mathjax:    true
catalog:    true
tags:
    - 分治
---

## 整体二分
### HDU5412
    #include <algorithm>
    #include <iostream>
    #include <cstring>
    #include <cstdio>
    #include <cmath>
    using namespace std;
    #define sc(p) scanf("%d",&p)
    #define pr(p) printf("%d\n",p)
    const int N=500100;
    const int oo=0x7FFFFFFF;
    struct DATA
    {
        int op,k,x,y,w;
    }s[N],S1[N],S2[N];
    int bit[N];
    void add (int x,int d) { for (int i=x; i<N; i+=i&-i) bit[i]+=d; }
    int sum (int x) { int sb=0; for (int i=x; i; i-=i&-i) sb+=bit[i]; return sb; }
    int a[N],ans[N];
    void solve (int l,int r,int L,int R)
    {
        if (l>r) return ;
        if (L==R)
        {
            for (int i=l; i<=r; i++)
                if (s[i].op==3) ans[s[i].w]=L;
            return ;
        }
        int mid=(L+R)>>1,w1=0,w2=0;
        for (int i=l; i<=r; i++)
        {
            if (s[i].op==3)
            {
                int tmp=sum (s[i].y)-sum (s[i].x-1);
                if (tmp>=s[i].k) S1[++w1]=s[i];
                else s[i].k-=tmp,S2[++w2]=s[i];
            }
            else
            {
                if (s[i].y<=mid) add (s[i].x,s[i].op),S1[++w1]=s[i];
                else S2[++w2]=s[i];
            }
        }
        for (int i=l; i<=r; i++)
            if (s[i].op!=3&&s[i].y<=mid) add (s[i].x,-s[i].op);
        for (int i=1; i<=w1; i++) s[l+i-1]=S1[i];
        for (int i=1; i<=w2; i++) s[l+w1+i-1]=S2[i];
        solve (l,l+w1-1,L,mid);
        solve (l+w1,r  ,mid+1,R);
    }
    int main()
    {
        int n;
        while(~scanf("%d",&n))
        {
            int q,cnt=0,tot=0,ma=0;
            for (int i=1; i<=n; i++)
            {
                sc(a[i]);
                s[++cnt].op=1,s[cnt].x=i,s[cnt].y=a[i];
                ma=max (ma,a[i]);
            }
            sc(q);
            for (int i=1; i<=q; i++)
            {
                int op,x,y; sc(op),sc(x),sc(y);
                if (op==1)
                {
                    s[++cnt].op=-1; s[cnt].x=x,s[cnt].y=a[x];
                    s[++cnt].op=1;  s[cnt].x=x,s[cnt].y=y;
                    ma=max (ma,y); a[x]=y;
                }
                else
                {
                    int k; sc(k);
                    s[++cnt].op=3;  s[cnt].x=x,s[cnt].y=y,s[cnt].k=k,s[cnt].w=++tot;
                }
            }
            solve (1,cnt,1,ma);
            for (int i=1; i<=tot; i++) pr(ans[i]);
        }
        return 0;
    }
    
### LuoguP3332
    #include <bits/stdc++.h>
    #define sc(p) scanf("%d",&p)
    #define pr(p) printf("%d\n",p)
    const int oo=2147483640;
    const int N=5010000;
    using namespace std;
    int bit[N+10];
    void add (int x,int d) { for (int i=x; i<=N; i+=i&-i) bit[i]+=d; }
    int sum (int x) { int sb=0; for (int i=x; i; i-=i&-i) sb+=bit[i]; return sb; }//蜜汁区间修改查询
    struct ASK { int id,ID,val,x,y; }p[N],tmp[N];
    bool ly (ASK A,ASK B) { return (A.x!=B.x) ? (A.x<B.x) : (A.id<B.id); }
    int ans[N];
    void solve (int l,int r)
    {
        if (l==r) return ;
        int mid=(l+r)>>1;
        for (int i=l; i<=r; i++)
        {
            if (p[i].ID==0&&p[i].id<=mid) add (p[i].y,p[i].val);
            if (p[i].ID> 0&&p[i].id> mid) ans[p[i].ID]+=sum (p[i].y)*p[i].val;
        }
        for (int i=l; i<=r; i++)
            if (p[i].ID==0&&p[i].id<=mid) add (p[i].y,-p[i].val);

        int w1=l,w2=mid+1;
        for (int i=l; i<=r; i++)
            if (p[i].id<=mid) tmp[w1++]=p[i];
            else              tmp[w2++]=p[i];
        for (int i=l; i<=r; i++) p[i]=tmp[i];

        solve (l,mid),solve (mid+1,r);
    }
    int main()
    {
        int lgj; sc(lgj),sc(lgj); int num=0,q=0;
        while (521)
        {
            int op; sc(op); if (op==3) break;
            if (op==1) q++,p[q].id=q,p[q].ID=0,sc(p[q].x),sc(p[q].y),sc(p[q].val);
            else 
            {
                int x1,y1,x2,y2; sc(x1),sc(y1),sc(x2),sc(y2); num++;
                q++,p[q].id=q,p[q].ID=num,p[q].x=x1-1,p[q].y=y1-1,p[q].val=1;
                q++,p[q].id=q,p[q].ID=num,p[q].x=x2  ,p[q].y=y2  ,p[q].val=1;
                q++,p[q].id=q,p[q].ID=num,p[q].x=x1-1,p[q].y=y2  ,p[q].val=-1;
                q++,p[q].id=q,p[q].ID=num,p[q].x=x2  ,p[q].y=y1-1,p[q].val=-1;
            }
        }
        sort (p+1,p+q+1,ly);
        solve (1,q);
        for (int i=1; i<=num; i++) pr(ans[i]);
        return 0;
    }

### 概念
对于一个问题，若单个询问能用二分快速解决，那么对于离线的多个询问，可以考虑使用整体二分。
整体二分二分的是答案。
### 栗
HDU5412：
首先将修改改为删除与插入。  
$l,r$表示的是要操作的区间，即编号在$l,r$之间的操作。  
$L,R$表示的是答案的范围。  
枚举操作（包括询问），若为修改，判断修改的数在左区间$\left[ L,mid \right]$或右区间$\left[ mid+1,R \right]$。  
若为左区间，则在树状数组中将修改的位置`+1`，并放入`S1`，否则放入`S2`。

    if (s[i].y<=mid) add (s[i].x,s[i].op),S1[++w1]=s[i];
    else                                  S2[++w2]=s[i];
    
这样保证了询问时得到的结果（询问区间内数的个数）中的数全部在区间$\left[ L,mid \right]$中。

    int tmp=sum (s[i].y)-sum (s[i].x-1);
    if (tmp>=s[i].k) S1[++w1]=s[i];
    else s[i].k-=tmp,S2[++w2]=s[i];
    
由此可以判断答案在$\left[ L,mid \right]$中或$\left[ mid+1,R \right]$中，并放入相应数组。  
由于每层都要清空树状数组，但`memset`又很慢，故应一个一个还原修改。  
最后将S1、S2合并到s。
## CDQ分治
对于离线的带有修改与询问的问题，若修改较难处理，且修改对询问的贡献能计算并合并，可以考虑使用CDQ分治。

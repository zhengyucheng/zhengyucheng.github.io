---
layout:     post
title:      "整体二分&CDQ分治"
subtitle:   "我永远喜欢LZZ"
date:       2018-08-13
author:     "JU"
header-img: "img/post-bg-2015.jpg"
mathjax:    true
catalog:    true
tags:
    - 分治
---

## 整体二分
### HDU5412
    #include <algorithm>
    #include <iostream>
    #include <cstring>
    #include <cstdio>
    #include <cmath>
    using namespace std;
    #define sc(p) scanf("%d",&p)
    #define pr(p) printf("%d\n",p)
    const int N=500100;
    const int oo=0x7FFFFFFF;
    struct DATA
    {
        int op,k,x,y,w;
    }s[N],S1[N],S2[N];
    int bit[N];
    void add (int x,int d) { for (int i=x; i<N; i+=i&-i) bit[i]+=d; }
    int sum (int x) { int sb=0; for (int i=x; i; i-=i&-i) sb+=bit[i]; return sb; }
    int a[N],ans[N];
    void solve (int l,int r,int L,int R)
    {
        if (l>r) return ;
        if (L==R)
        {
            for (int i=l; i<=r; i++)
                if (s[i].op==3) ans[s[i].w]=L;
            return ;
        }
        int mid=(L+R)>>1,w1=0,w2=0;
        for (int i=l; i<=r; i++)
        {
            if (s[i].op==3)
            {
                int tmp=sum (s[i].y)-sum (s[i].x-1);
                if (tmp>=s[i].k) S1[++w1]=s[i];
                else s[i].k-=tmp,S2[++w2]=s[i];
            }
            else
            {
                if (s[i].y<=mid) add (s[i].x,s[i].op),S1[++w1]=s[i];
                else S2[++w2]=s[i];
            }
        }
        for (int i=l; i<=r; i++)
            if (s[i].op!=3&&s[i].y<=mid) add (s[i].x,-s[i].op);
        for (int i=1; i<=w1; i++) s[l+i-1]=S1[i];
        for (int i=1; i<=w2; i++) s[l+w1+i-1]=S2[i];
        solve (l,l+w1-1,L,mid);
        solve (l+w1,r  ,mid+1,R);
    }
    int main()
    {
        int n;
        while(~scanf("%d",&n))
        {
            int q,cnt=0,tot=0,ma=0;
            for (int i=1; i<=n; i++)
            {
                sc(a[i]);
                s[++cnt].op=1,s[cnt].x=i,s[cnt].y=a[i];
                ma=max (ma,a[i]);
            }
            sc(q);
            for (int i=1; i<=q; i++)
            {
                int op,x,y; sc(op),sc(x),sc(y);
                if (op==1)
                {
                    s[++cnt].op=-1; s[cnt].x=x,s[cnt].y=a[x];
                    s[++cnt].op=1;  s[cnt].x=x,s[cnt].y=y;
                    ma=max (ma,y); a[x]=y;
                }
                else
                {
                    int k; sc(k);
                    s[++cnt].op=3;  s[cnt].x=x,s[cnt].y=y,s[cnt].k=k,s[cnt].w=++tot;
                }
            }
            solve (1,cnt,1,ma);
            for (int i=1; i<=tot; i++) pr(ans[i]);
        }
        return 0;
    }
    
### LuoguP3332
    #include <bits/stdc++.h>
    #define sc(p) scanf("%d",&p)
    #define pr(p) printf("%d\n",p)
    const int oo=2147483640;
    const int N=5010000;
    using namespace std;
    int bit[N+10];
    void add (int x,int d) { for (int i=x; i<=N; i+=i&-i) bit[i]+=d; }
    int sum (int x) { int sb=0; for (int i=x; i; i-=i&-i) sb+=bit[i]; return sb; }//蜜汁区间修改查询
    struct ASK { int id,ID,val,x,y; }p[N],tmp[N];
    bool ly (ASK A,ASK B) { return (A.x!=B.x) ? (A.x<B.x) : (A.id<B.id); }
    int ans[N];
    void solve (int l,int r)
    {
        if (l==r) return ;
        int mid=(l+r)>>1;
        for (int i=l; i<=r; i++)
        {
            if (p[i].ID==0&&p[i].id<=mid) add (p[i].y,p[i].val);
            if (p[i].ID> 0&&p[i].id> mid) ans[p[i].ID]+=sum (p[i].y)*p[i].val;
        }
        for (int i=l; i<=r; i++)
            if (p[i].ID==0&&p[i].id<=mid) add (p[i].y,-p[i].val);

        int w1=l,w2=mid+1;
        for (int i=l; i<=r; i++)
            if (p[i].id<=mid) tmp[w1++]=p[i];
            else              tmp[w2++]=p[i];
        for (int i=l; i<=r; i++) p[i]=tmp[i];

        solve (l,mid),solve (mid+1,r);
    }
    int main()
    {
        int lgj; sc(lgj),sc(lgj); int num=0,q=0;
        while (521)
        {
            int op; sc(op); if (op==3) break;
            if (op==1) q++,p[q].id=q,p[q].ID=0,sc(p[q].x),sc(p[q].y),sc(p[q].val);
            else 
            {
                int x1,y1,x2,y2; sc(x1),sc(y1),sc(x2),sc(y2); num++;
                q++,p[q].id=q,p[q].ID=num,p[q].x=x1-1,p[q].y=y1-1,p[q].val=1;
                q++,p[q].id=q,p[q].ID=num,p[q].x=x2  ,p[q].y=y2  ,p[q].val=1;
                q++,p[q].id=q,p[q].ID=num,p[q].x=x1-1,p[q].y=y2  ,p[q].val=-1;
                q++,p[q].id=q,p[q].ID=num,p[q].x=x2  ,p[q].y=y1-1,p[q].val=-1;
            }
        }
        sort (p+1,p+q+1,ly);
        solve (1,q);
        for (int i=1; i<=num; i++) pr(ans[i]);
        return 0;
    }

### 概念
对于一个问题，若单个询问能用二分快速解决，那么对于离线的多个询问，可以考虑使用整体二分。
整体二分二分的是答案。
### 栗
HDU5412：
首先将修改改为删除与插入。  
$l,r$表示的是要操作的区间，即编号在$l,r$之间的操作。  
$L,R$表示的是答案的范围。  
枚举操作（包括询问），若为修改，判断修改的数在左区间$\left[ L,mid \right]$或右区间$\left[ mid+1,R \right]$。  
若为左区间，则在树状数组中将修改的位置`+1`，并放入`S1`，否则放入`S2`。

    if (s[i].y<=mid) add (s[i].x,s[i].op),S1[++w1]=s[i];
    else                                  S2[++w2]=s[i];
    
这样保证了询问时得到的结果（询问区间内数的个数）中的数全部在区间$\left[ L,mid \right]$中。

    int tmp=sum (s[i].y)-sum (s[i].x-1);
    if (tmp>=s[i].k) S1[++w1]=s[i];
    else s[i].k-=tmp,S2[++w2]=s[i];
    
由此可以判断答案在$\left[ L,mid \right]$中或$\left[ mid+1,R \right]$中，并放入相应数组。  
由于每层都要清空树状数组，但`memset`又很慢，故应一个一个还原修改。  
最后将`S1`、`S2`合并到`s`。
## CDQ分治
### LuoguP3810
    #include <bits/stdc++.h>
    using namespace std;
    #define sc(p) scanf("%d",&p)
    const int N=1000100;
    const int oo=0x7FFFFFFF;
    struct LGJ
    {
        int w,x,y,z;
    }p[N];
    int n;
    bool CMP1 (LGJ a,LGJ b)
    {
        if (a.x!=b.x) return a.x<b.x;
        if (a.y!=b.y) return a.y<b.y;
        return a.z<b.z;
    }
    bool CMP2 (LGJ a,LGJ b)
    {
        if (a.y!=b.y) return a.y<b.y;
        if (a.z!=b.z) return a.z<b.z;
        return a.x<b.x;
    }
    bool CMP3 (LGJ a,LGJ b) { return a.w<b.w; }
    int same[N],ans[N];
    int bit[N];
    int lowbit (int x) { return x&-x; }
    void add (int x,int d) { for (int i=x; i<=N; i+=lowbit(i)) bit[i]+=d; }
    int sum (int x) { int sb=0; for (int i=x; i; i-=lowbit(i)) sb+=bit[i]; return sb; }
    void cdq (int l,int r)
    {
        if (l==r) return ;
        int mid=(l+r)/2;
        cdq (l,mid); cdq (mid+1,r);
        sort (p+l,p+r+1,CMP2);

        for (int i=l; i<=r; i++)
        if (p[i].x<=mid) add (p[i].z,1);
        else ans[p[i].w]+=sum (p[i].z);

        for (int i=l; i<=r; i++)
        if (p[i].x<=mid) add (p[i].z,-1);
    }
    int d[N];
    int main()
    {
        int k; sc(n),sc(k);
        for (int i=1; i<=n; i++)
        sc(p[i].x),sc(p[i].y),sc(p[i].z),p[i].w=i;
        sort (p+1,p+n+1,CMP1);
        for (int i=1; i<=n; )
        {
            int j=i+1;
            while (j<=n&&p[i].x==p[j].x&&p[i].y==p[j].y&&p[i].z==p[j].z) j++;
            while(i<j) same[p[i++].w]=p[j-1].w;
        }
        for (int i=1; i<=n; i++) p[i].x=i;
        cdq (1,n);
        sort (p+1,p+n+1,CMP3);
        for (int i=1; i<=n; i++) d[ ans[same[p[i].w]] ]++;
        for (int i=0; i<n; i++) cout<<d[i]<<endl;
        return 0;
    } 

### LuoguP4390
    #include <bits/stdc++.h>
    #define sc(p) scanf("%d",&p)
    #define pr(p) printf("%d\n",p)
    const int oo=2147483640;
    const int N=5010000;
    using namespace std;
    int bit[N+10];
    void add (int x,int d) { for (int i=x; i<=N; i+=i&-i) bit[i]+=d; }
    int sum (int x) { int sb=0; for (int i=x; i; i-=i&-i) sb+=bit[i]; return sb; }
    struct ASK { int id,ID,val,x,y; }p[N],tmp[N];
    bool ly (ASK A,ASK B) { return (A.x!=B.x) ? (A.x<B.x) : (A.id<B.id); }
    int ans[N];
    void cdq (int l,int r)
    {
        if (l==r) return ;
        int mid=(l+r)>>1;
        for (int i=l; i<=r; i++)
        {
            if (p[i].ID==0&&p[i].id<=mid) add (p[i].y,p[i].val);
            if (p[i].ID> 0&&p[i].id> mid) ans[p[i].ID]+=sum (p[i].y)*p[i].val;
        }
        for (int i=l; i<=r; i++)
            if (p[i].ID==0&&p[i].id<=mid) add (p[i].y,-p[i].val);

        int w1=l,w2=mid+1;
        for (int i=l; i<=r; i++)
            if (p[i].id<=mid) tmp[w1++]=p[i];
            else              tmp[w2++]=p[i];
        for (int i=l; i<=r; i++) p[i]=tmp[i];

        cdq (l,mid),cdq (mid+1,r);
    }
    int main()
    {
        int lgj; sc(lgj),sc(lgj); int num=0,q=0;
        while (521)
        {
            int op; sc(op); if (op==3) break;
            if (op==1) q++,p[q].id=q,p[q].ID=0,sc(p[q].x),sc(p[q].y),sc(p[q].val);
            else 
            {
                int x1,y1,x2,y2; sc(x1),sc(y1),sc(x2),sc(y2); num++;
                q++,p[q].id=q,p[q].ID=num,p[q].x=x1-1,p[q].y=y1-1,p[q].val=1;
                q++,p[q].id=q,p[q].ID=num,p[q].x=x2  ,p[q].y=y2  ,p[q].val=1;
                q++,p[q].id=q,p[q].ID=num,p[q].x=x1-1,p[q].y=y2  ,p[q].val=-1;
                q++,p[q].id=q,p[q].ID=num,p[q].x=x2  ,p[q].y=y1-1,p[q].val=-1;
            }
        }
        sort (p+1,p+q+1,ly);
        cdq (1,q);
        for (int i=1; i<=num; i++) pr(ans[i]);
        return 0;
    }

### 概念
对于离线的带有修改与询问的问题，若修改较难处理，且修改对询问的贡献能计算并合并，可以考虑使用`CDQ`分治。
### 栗
PS：两题采用不同写法
**LuoguP3810：**  
首先按`x`排序，进行分治。  
对于每个区间$l,r$，其子区间已递归完毕。  
先再次按照`y`排序，可知任意区间内，$l,r$的范围即为`p[l~r].x`的范围（预处理）。  
此时按照x将每个三元组分到左区间与右区间，并计算左区间对右区间的贡献。  
还原修改。  
**LuoguP4390：**  
小小的容斥（自行思考），每个询问拆成四个。  
先按第一维`x`排序。
分治时，枚举每个操作与询问，进行编号在左半边的操作，查询编号在右半边的询问。  
为保证有效，只查询当前询问之前的操作。  
如此计算左边对右边贡献。
## %%%wzj
**整体二分是查答案，CDQ分治是记贡献——wzj**

---
layout:     post
title:      "高斯消元"
subtitle:   "这是什么“玩意”"
date:       2018-07-17
author:     "JU"
header-img: "img/post-bg-2015.jpg"
mathjax:    false
catalog:    true
tags:
    - 数论
---


## BZOJ1013（普通方程）


    #include <bits/stdc++.h>
    #define sc(p) scanf("%d",&p)
    #define sc2(p1,p2) scanf("%d%d",&p1,&p2)
    #define sc3(p1,p2,p3) scanf("%d%d%d",&p1,&p2,&p3)
    #define pr(p) printf("%d\n",p)
    using namespace std;
    const int N=20;
    const int oo=2139062143;   //0x7f
    const double eps=1e-6;
    double a[N][N],ans[N];
    int n,m;
    int gauss()
    {
        if (m<n) return 0;
        for (int i=1; i<=n; i++)
        {
            int k=i;
            for (int j=i+1; j<=m; j++) if (abs(a[k][i])<abs(a[j][i])) k=j;
            for (int j=1; j<=n+1; j++) swap(a[i][j],a[k][j]);
            if (abs(a[i][i])<eps) return 0;
            for (int j=1; j<=m; j++) if (j!=i)
            {
                double p=a[j][i]/a[i][i];
                for (int k=1; k<=n+1; k++) a[j][k]-=a[i][k]*p;
            }
        }
        for (int i=n+1; i<=m; i++) if (abs(a[i][n+1])>eps) return 0;
        for (int i=1; i<=n; i++) ans[i]=a[i][n+1]/a[i][i];
        return 1;
    }
    double sb[N][N];
    int main()
    {
        //freopen(".in","r",stdin);
        //freopen(".out","w",stdout);
        sc(n); m=n;
        for (int i=1; i<=n+1; i++)
        for (int j=1; j<=n; j++) cin>>sb[i][j];

        for (int i=1; i<=n; i++)
        {
            double sum=0;
            for (int j=1; j<=n; j++)
            {
                double s1=sb[i][j],s2=sb[i+1][j];
                a[i][j]=2*(s1-s2),sum+=s1*s1-s2*s2;
            }	
            a[i][n+1]=sum;
        }
        gauss ();
        for (int i=1; i<=n; i++)
        printf ("%.3lf ",ans[i]);
        return 0;
    }


## BZOJ1923（异或方程）
    void gauss ()
    {
        for (register int i=1; i<=n; i++)
        {
            register int j=i;
            while (!a[j][i]&&j<=m) j++;
            if (j==m+1) { ans=-1; return ; }
            else ans=max(ans,j);
            swap(a[j],a[i]);
            for(register int k=1;k<=m;k++) if(k!=i&&a[k][i])
            for(register int l=1;l<=n+1;l++)
            a[k][l]^=a[i][l];
        }
    }
    
## POJ2947（同余方程）
    #include <cstdio>
    #include <algorithm>
    #include <cstring>
    using namespace std;
    const int mod=7;
    int n,m;
    int a[300+10][300+10];
    char c1[10],c2[10],c[10][10]={"1","MON","TUE","WED","THU","FRI","SAT","SUN"};//星期几
    int get(char p[]) { for (int i=1;i<=7;i++) if(!strcmp(p,c[i])) return i; }
    int gauss()
    {
        int i,j;
        for (i=1,j=1;i<=m&&j<=n;j++)
        {
            int k=i;
            while(k<=m&&!a[k][j]) k++;//找一个1...j前序数全为零的方程
            if(a[k][j])
            {
                for (int p=1;p<=n+1;p++) swap(a[k][p],a[i][p]);//把k行序数与i行交换保证了阶梯矩阵
                for (int h=1;h<=m;h++) if (h!=i)
                {
                    if(a[h][j])
                    {
                        int x=a[i][j],y=a[h][j];
                        for (int p=1;p<=n+1;p++) a[h][p]=((a[h][p]*x-a[i][p]*y)%mod+mod)%mod;
                    }
                }
                i++;
            }
        }
        for (int p=i;p<=m;p++) if(a[p][n+1]) return -1;
        if(i<=n) return n-i+1;

        for (int x=n;x>=1;x--)
        {
            while(a[x][n+1]%a[x][x]!=0) a[x][n+1]+=7;
            a[x][n+1]=(a[x][n+1]/a[x][x])%mod;
        }

        return 0;
    }
    int main()
    {
        while(scanf("%d%d",&n,&m)&&n)
        {
            int k,v;
            memset(a,0,sizeof(a));
            for (int i=1;i<=m;i++)
            {
                scanf("%d%s%s",&k,c1,c2);
                a[i][n+1]=(get(c2)-get(c1)+8)%mod;
                for (int j=1;j<=k;j++) { scanf("%d",&v); a[i][v]++; }
                for (int j=1;j<=n;j++) a[i][j]%=7;
            }
            int t=gauss();
            if(t==-1) printf("Inconsistent data.\n");
            else if(t) printf("Multiple solutions.\n");
            else
            {
                for (int i=1;i<=n;i++)
                    if(a[i][n+1]<3) a[i][n+1]+=mod;
                for (int i=1;i<n;i++) printf("%d ",a[i][n+1]);
                printf("%d\n",a[n][n+1]);
            }
        }
        return 0;
    }

## 行列式
![](/img/行列式.png)
## 线性基
![](/img/线性基.png)

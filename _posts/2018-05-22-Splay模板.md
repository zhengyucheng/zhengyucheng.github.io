---
layout:     post
title:      "Splay（模板）"
subtitle:   "模板"
date:       2018-05-22
author:     "JU"
header-img: "img/post-bg-2015.jpg"
mathjax:    false
catalog:    true
tags:
    - 数据结构
---

## POJ3580

        #include <algorithm>
        #include <iostream>
        #include <cstring>
        #include <string>
        #include <cstdio>
        #include <cmath>
        #include <queue>
        #define sc(p) scanf("%d",&p)
        #define pr(p) printf("%d",p)
        const int oo=0x7FFFFFFF;
        const int o=0x3FFFFFFF;
        const int N=300100;
        using namespace std;
        struct SPLAY
        {
            int fa,son[2],size,mi,lazy1,lazy2,w;
            #define fa(p) t[p].fa
            #define son(p) t[p].son
            #define size(p) t[p].size
            #define lazy1(p) t[p].lazy1
            #define lazy2(p) t[p].lazy2
            #define mi(p) t[p].mi
            #define w(p) t[p].w
        }t[N]; int tot=0,root;
        int tmp[N];
        void add (int x,int f)
        {
            tot++;
            fa(tot)=f; son(tot)[0]=son(tot)[1]=lazy1(tot)=lazy2(tot)=0; size(tot)=1; mi(tot)=w(tot)=x;
        }
        void update (int x)
        {
            if (!x) return ;
            size(x)=1; mi(x)=w(x);
            if (son(x)[0]) size(x)+=size(son(x)[0]),mi(x)=min (mi(x),mi(son(x)[0]));
            if (son(x)[1]) size(x)+=size(son(x)[1]),mi(x)=min (mi(x),mi(son(x)[1]));
        }
        void update_add (int x,int k) { if (x) mi(x)+=k,lazy2(x)+=k,w(x)+=k; }
        void update_rev (int x) { if (x) lazy1(x)^=1,swap (son(x)[0],son(x)[1]); }
        void push (int x)
        {
            if (!x) return ;
            if (lazy2(x)) update_add (son(x)[0],lazy2(x)),update_add (son(x)[1],lazy2(x)),lazy2(x)=0;
            if (lazy1(x)) update_rev (son(x)[0]),update_rev (son(x)[1]),lazy1(x)=0;
        }
        int build (int l,int r,int f)
        {
            int mid=(l+r)/2,tt;
            add (tmp[mid],f); tt=tot;
            if (l<mid) son(tt)[0]=build (l,mid-1,tt);
            if (r>mid) son(tt)[1]=build (mid+1,r,tt);
            update (tt);
            return tt;
        }
        int get (int x) { return son(fa(x))[1]==x; }
        void rotate (int x)
        {
            int f=fa(x),ff=fa(f),son=get(x);
            push (f),push (x);
            son(f)[son]=son(x)[son^1];
            if (son(f)[son]) fa(son(f)[son])=f;
            son(x)[son^1]=f,fa(f)=x;
            if (ff) son(ff)[son(ff)[1]==f]=x;
            fa(x)=ff;
            update (f),update(x);
        }
        void splay (int x,int to)
        {
            push (x);
            if (x==to||fa(x)==to) return ;
            for (int f; (f=fa(x))&&(f!=to); rotate (x))
            {
                push (fa(fa(x))),push (fa(x)),push (x);
                if (fa(f)!=to) rotate ( (get (x)==get (f)) ? f : x);
                if (fa(x)==to) break; 
            }
            update (x);
            if (to==0) root=x;
        }
        int rank (int k,int pos)
        {
            push (pos);
            if (size(son(pos)[0])+1==k) return pos;
            if (size(son(pos)[0])>=k) return rank (k,son(pos)[0]);
            else return rank (k-size(son(pos)[0])-1,son(pos)[1]);
        }



        void addd (int l,int r,int k)
        {
            int x=rank (l,root),y=rank(r+2,root);
            splay (x,0),splay (y,x);
            update_add (son(y)[0],k);
        }
        void rev (int l,int r)
        {
            int x=rank (l,root),y=rank(r+2,root);
            splay (x,0),splay (y,x);
            lazy1 (son(y)[0])^=1;
            swap (son(son(y)[0])[0],son(son(y)[0])[1]);
        }
        void res (int l1,int r1,int l2,int r2)
        {
            int x=rank (l2,root),y=rank (r2+2,root);
            splay (x,0),splay (y,x);
            int tt=son(y)[0];
            son(y)[0]=0; fa(tt)=0;
            x=rank (l1,root),y=rank (l1+1,root);
            splay (x,0),splay (y,x);
            son(y)[0]=tt; fa(tt)=y;
        }
        void ins (int p,int k)
        {
            int x=rank (p+1,root),y=rank (p+2,root);
            splay (x,0),splay (y,x);
            add (k,y); son(y)[0]=tot;
            push (y),update (y);
            push (x),update (x);
            splay (y,0);
        }
        void clear (int x) { fa(x)=son(x)[0]=son(x)[1]=w(x)=size(x)=lazy1(x)=lazy2(x)=0; }
        void del (int p)
        {
            int x=rank (p,root),y=rank (p+2,root);
            splay (x,0),splay (y,x);
            clear (son(y)[0]); son(y)[0]=0;
            update (y),update (x);
        }
        int getmin (int l,int r)
        {
            int x=rank (l,root),y=rank (r+2,root);
            splay (x,0),splay (y,x);
            return mi(son(y)[0]);
        }
        int main()
        {
            //freopen (".in","r",stdin);
            //freopen (".out","w",stdout);
            int n; sc(n);
            for (int i=1; i<=n; i++) sc(tmp[i]);
            tmp[0]=tmp[n+1]=oo;
            root=build (0,n+1,0);
            int m; sc(m);
            for (int i=1; i<=m; i++)
            {
                int t1,t2,t3;
                char s[10]; scanf ("%s",s);
                if (s[0]=='A')
                {
                    sc(t1),sc(t2),sc(t3);
                    addd (t1,t2,t3);
                }//t1~t2Çø¼ä+t3 
                if (s[0]=='R')
                {
                    if (s[3]=='O')
                    {
                        sc(t1),sc(t2),sc(t3);
                        int g=t2-t1+1;
                        t3=(t3%g+g)%g;
                        if (t3==0) continue;
                        res (t1,t2-t3,t2-t3+1,t2);
                    }
                    else { sc(t1),sc(t2); rev (t1,t2); }//Çø¼ä·­×ª 
                }
                if (s[0]=='I') { sc(t1),sc(t2); ins (t1,t2); }//ÔÚt1Î»ÖÃºóÃæ²åÈët2 
                if (s[0]=='D') { sc(t1); del(t1); }//É¾³ýt1Î»ÖÃµÄÊý 
                if (s[0]=='M') { sc(t1),sc(t2); pr(getmin (t1,t2)),cout<<"\n"; }
            }
            return 0;
        }


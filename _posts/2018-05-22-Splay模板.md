---
layout:     post
title:      "Splay（模板）"
subtitle:   "模板"
date:       2018-05-22
author:     "JU"
header-img: "img/post-bg-2015.jpg"
mathjax:    false
catalog:    true
tags:
    - 数据结构
---

## luoguP2042

        #include <algorithm>
        #include <iostream>
        #include <cstring>
        #include <string>
        #include <cstdio>
        #include <cmath>
        #include <queue>
        #define sc(p) scanf("%d",&p)
        #define pr(p) printf("%d",p)
        const int oo=0x7FFFFFFF;
        const int o=0x3FFFFFFF/5;
        const int N=3000100;
        using namespace std;
        struct SPLAY
        {
            int fa,son[2],size,lazy1,lazy2,sam,w;
            int sum,lmax,rmax,maxx,ma;
            #define fa(p) t[p].fa
            #define son(p) t[p].son
            #define size(p) t[p].size
            #define lazy1(p) t[p].lazy1
            #define lazy2(p) t[p].lazy2
            #define w(p) t[p].w
            #define sum(p) t[p].sum
            #define lmax(p) t[p].lmax
            #define rmax(p) t[p].rmax
            #define maxx(p) t[p].maxx
            #define sam(p) t[p].sam
            #define ma(p) t[p].ma
        }t[N]; int tot=0,root;
        int tmp[N];
        void add (int x,int f)
        {
            tot++;
            fa(tot)=f;
            son(tot)[0]=son(tot)[1]=lazy1(tot)=lazy2(tot)=0;
            size(tot)=1; w(tot)=sum(tot)=ma(tot)=x;
            lmax(tot)=rmax(tot)=maxx(tot)=max (x,0);
        }
        void update (int x)
        {
            if (!x) return ;
            size(x)=1; sum(x)=w(x);
            int ls=son(x)[0],rs=son(x)[1];
            ma(x)=w(x);
            if (ls) size(x)+=size(ls),sum(x)+=sum(ls),ma(x)=max(ma(x),ma(ls));
            if (rs) size(x)+=size(rs),sum(x)+=sum(rs),ma(x)=max(ma(x),ma(rs));
            lmax(x)=max (lmax(ls),max (sum(ls)+w(x),sum(ls)+w(x)+lmax(rs)));
            rmax(x)=max (rmax(rs),max (sum(rs)+w(x),sum(rs)+w(x)+rmax(ls)));
            maxx(x)=max (max (maxx(ls),maxx(rs)),rmax(ls)+w(x)+lmax(rs));
        }
        void update_same (int x,int k)
        {
            if (x) sum(x)=k*size(x),sam(x)=k,w(x)=k,lazy2(x)=1,ma(x)=k;
            if (k>0) lmax(x)=rmax(x)=maxx(x)=sum(x);
            else lmax(x)=rmax(x)=0,maxx(x)=k;
        }
        void update_rev (int x) { if (x) lazy1(x)^=1,swap (son(x)[0],son(x)[1]),swap (lmax(x),rmax(x)); }
        void push (int x)
        {
            if (!x) return ;
            if (lazy2(x))
            update_same (son(x)[0],sam(x)),update_same (son(x)[1],sam(x)),lazy2(x)=0,ma(x)=sam(x),sam(x)=0;
            if (lazy1(x)) update_rev (son(x)[0]),update_rev (son(x)[1]),lazy1(x)=0;
        }
        int build (int l,int r,int f)
        {
            int mid=(l+r)/2,tt;
            add (tmp[mid],f); tt=tot;
            if (l<mid) son(tt)[0]=build (l,mid-1,tt);
            if (r>mid) son(tt)[1]=build (mid+1,r,tt);
            update (tt);
            return tt;
        }
        int get (int x) { return son(fa(x))[1]==x; }
        void rotate (int x)
        {
            int f=fa(x),ff=fa(f),son=get(x);
            push (f),push (x);
            son(f)[son]=son(x)[son^1];
            if (son(f)[son]) fa(son(f)[son])=f;
            son(x)[son^1]=f,fa(f)=x;
            if (ff) son(ff)[son(ff)[1]==f]=x;
            fa(x)=ff;
            update (f),update(x);
        }
        void splay (int x,int to)
        {
            push (x);
            if (x==to||fa(x)==to) return ;
            for (int f; (f=fa(x))&&(f!=to); rotate (x))
            {
                push (fa(fa(x))),push (fa(x)),push (x);
                if (fa(f)!=to) rotate ( (get (x)==get (f)) ? f : x);
                if (fa(x)==to) break; 
            }
            update (x);
            if (to==0) root=x;
        }
        int rank (int k,int pos)
        {
            push (pos);
            if (size(son(pos)[0])+1==k) return pos;
            if (size(son(pos)[0])>=k) return rank (k,son(pos)[0]);
            else return rank (k-size(son(pos)[0])-1,son(pos)[1]);
        }


        void rev (int l,int r)
        {
            int x=rank (l,root),y=rank(r+2,root);
            splay (x,0),splay (y,x);
            lazy1 (son(y)[0])^=1;
            swap (son(son(y)[0])[0],son(son(y)[0])[1]);
            swap (lmax(son(y)[0]),rmax(son(y)[0]));
            update (y),update (x);
        }
        void insqujian (int l,int len)
        {
            int x=rank (l,root),y=rank (l+1,root);
            splay (x,0),splay (y,x);
            son(y)[0]=build (1,len,y);
            update (y),update (x);
        }
        void clear (int x)
        {
            fa(x)=son(x)[0]=son(x)[1]=w(x)=size(x)=lazy1(x)=lazy2(x)=lmax(x)=rmax(x)=maxx(x)=sam(x)=0;
        }
        void del (int l,int r)
        {
            int x=rank (l,root),y=rank (r+2,root);
            splay (x,0),splay (y,x);
            clear (son(y)[0]); son(y)[0]=0;
            update (y),update (x);
        }
        int getsum (int l,int r)
        {
            int x=rank (l,root),y=rank (r+2,root);
            splay (x,0),splay (y,x);
            return sum(son(y)[0]);
        }
        void makesame (int l,int r,int k)
        {
            int x=rank (l,root),y=rank (r+2,root);
            splay (x,0),splay (y,x);
            update_same (son(y)[0],k);
            update (y),update (x);
        }
        int maxsum (int l,int r)
        {
            int x=rank (l,root),y=rank (r+2,root);
            splay (x,0),splay (y,x);
            if (ma(son(y)[0])<0) return ma(son(y)[0]);
            return maxx(son(y)[0]);
        }
        int sb[N];
        int main()
        {
            //freopen ("data.out","r",stdin);
            //freopen ("mine.out","w",stdout);
            int n,m; sc(n),sc(m);
            for (int i=1; i<=n; i++) sc(tmp[i]);
            tmp[0]=tmp[n+1]=-o;
            root=build (0,n+1,0);
            int num=n;
            for (int i=1; i<=m; i++)
            {
                char s[10]; scanf ("%s",s);
                if (s[2]=='X')
                { cout<<maxsum (1,num)<<endl; continue; }
                int pos,tf; sc(pos),sc(tf);
                if (s[0]=='I')
                {
                    for (int j=1; j<=tf; j++) sc(tmp[j]);
                    insqujian (pos+1,tf);
                    num+=tf;
                }
                if (s[0]=='D') del (pos,pos+tf-1),num-=tf;
                if (s[2]=='K')
                {
                    int c; sc(c);
                    makesame (pos,pos+tf-1,c);
                }
                if (s[0]=='G') cout<<getsum (pos,pos+tf-1)<<endl;
                if (s[0]=='R') rev (pos,pos+tf-1);
            }
            return 0;
        }

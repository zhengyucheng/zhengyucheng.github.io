---
layout:     post
title:      "Splay"
subtitle:   ""
date:       2018-05-22
author:     "JU"
header-img: "img/post-bg-2015.jpg"
mathjax:    false
catalog:    true
tags:
    - 数据结构
---

### LuoguP3391


	#include <bits/stdc++.h>
	#define pr(p) printf("%d ",p)
	const int oo=2139063143;
	const int N=1010000;
	const int mod=1000000007;
	using namespace std;
	typedef long long LL;
	inline void sc (int &x)
	{
		x=0; static int p; p=1; static char c; c=getchar();
		while (!isdigit(c)) { if (c=='-') p=-1; c=getchar(); }
		while ( isdigit(c)) { x=(x<<1)+(x<<3)+(c-48); c=getchar(); }
		x*=p;
	}
	int n,m,tmp[N];
	struct SPLAY { int fa,son[2],siz,laz,w; }t[N]; int tot=0,root;
	#define fa(p) t[p].fa
	#define son(p) t[p].son
	#define siz(p) t[p].siz
	#define laz(p) t[p].laz
	#define w(p) t[p].w
	int add (int x,int f)
	{
		int p=++tot;
		fa(p)=f;
		son(p)[0]=son(p)[1]=0;
		siz(p)=1; w(p)=x;
		return p;
	}
	void update (int p)
	{
		siz(p)=1;
		int ls=son(p)[0],rs=son(p)[1];
		if (ls) siz(p)+=siz(ls);
		if (rs) siz(p)+=siz(rs);
	}
	void updaterev (int p)
	{
		laz(p)^=1;
		swap (son(p)[0],son(p)[1]);
	}
	void push (int p)
	{
		if (!laz(p)) return ;
		laz(p)^=1;
		updaterev (son(p)[0]),updaterev (son(p)[1]);
	}
	int build (int l,int r,int f)
	{
		int mid=(l+r)>>1,p=add (tmp[mid],f);
		if (l< mid) son(p)[0]=build (l,mid-1,p);
		if (r> mid) son(p)[1]=build (mid+1,r,p);
		update (p);
		return p;
	}
	int get (int p) { return son(fa(p))[1]==p; }
	void rotate (int p)
	{
		int f=fa(p),ff=fa(f),s=get(p);
		son(f)[s]=son(p)[s^1];
		if (son(f)[s]) fa(son(f)[s])=f;
		son(p)[s^1]=f,fa(f)=p;
		if (ff) son(ff)[son(ff)[1]==f]=p;
		fa(p)=ff;
		update (f),update (p);
	}
	void splay (int p,int to)
	{
		while (fa(p)!=to)
		{
			int f=fa(p),ff=fa(f);
			if (ff!=to)
				rotate (get(p)==get(f)?f:p);
			rotate (p);
		}
		if (to==0) root=p;
	}
	int find (int p,int k)
	{
		push (p);
		int ls=son(p)[0],rs=son(p)[1];
		if (siz(ls)+1==k) return p;
		if (siz(ls)  >=k) return find (ls,k);
		return find (rs,k-siz(ls)-1);
	}
	void reverse (int l,int r)
	{
		int x=find (root,l),y=find (root,r+2);
		splay (x,0),splay (y,x);
		int p=son(y)[0];
		laz(p)^=1;
		swap(son(p)[0],son(p)[1]);
		update (y),update (x);
	}
	void print (int p)
	{
		if (!p) return ;
		push (p);
		int ls=son(p)[0],rs=son(p)[1];
		print (ls);
		if (w(p)>=1&&w(p)<=n) pr(w(p));
		print (rs);
	}
	int main()
	{
		//freopen (".in","r",stdin);
		//freopen (".out","w",stdout);
		sc(n),sc(m);
		for (int i=1; i<=n; i++)
			tmp[i]=i;
		tmp[0]=tmp[n+1]=-oo/10;
		root=build (0,n+1,0);
		while (m--)
		{
			int l,r; sc(l),sc(r);
			reverse (l,r); 
		}
		print (root);
		return 0;
	}

### LuoguP2042

	#include <bits/stdc++.h>
	#define pr(p) printf("%d\n",p)
	const int oo=2139063143;
	const int N=1010000;
	const int mod=1000000007;
	using namespace std;
	typedef long long LL;
	inline void sc (int &x)
	{
	    x=0; static int p; p=1; static char c; c=getchar();
	    while (!isdigit(c)) { if (c=='-') p=-1; c=getchar(); }
	    while ( isdigit(c)) { x=(x<<1)+(x<<3)+(c-48); c=getchar(); }
	    x*=p;
	}
	struct SPLAY
	{
	    int fa,son[2],siz,laz1,laz2,sam,w;
	    int sum,lmax,rmax,maxx,ma;
	}t[N]; int tot=0,root;
	#define fa(p) t[p].fa
	#define son(p) t[p].son
	#define siz(p) t[p].siz
	#define laz1(p) t[p].laz1
	#define laz2(p) t[p].laz2
	#define sam(p) t[p].sam
	#define w(p) t[p].w
	#define sum(p) t[p].sum
	#define lmax(p) t[p].lmax
	#define rmax(p) t[p].rmax
	#define maxx(p) t[p].maxx
	#define ma(p) t[p].ma
	int tmp[N],las[N];
	int add (int x,int f)
	{
	    int p=las[0]?las[las[0]--]:++tot;
	    fa(p)=f;
	    son(p)[0]=son(p)[1]=laz1(p)=laz2(p)=sam(p)=0;
	    siz(p)=1; w(p)=sum(p)=ma(p)=x;
	    lmax(p)=rmax(p)=maxx(p)=max (x,0);
	    return p;
	}
	void update (int p)
	{
	    siz(p)=1; sum(p)=ma(p)=w(p);
	    int ls=son(p)[0],rs=son(p)[1];
	    siz(p)+=siz(ls)+siz(rs),sum(p)+=sum(ls)+sum(rs);
	    if (ls) ma(p)=max (ma(p),ma(ls));
	    if (rs) ma(p)=max (ma(p),ma(rs));
	    lmax(p)=max (lmax(ls),max (sum(ls)+w(p),sum(ls)+w(p)+lmax(rs)));
	    rmax(p)=max (rmax(rs),max (sum(rs)+w(p),sum(rs)+w(p)+rmax(ls)));
	    maxx(p)=max (max (maxx(ls),maxx(rs)),rmax(ls)+w(p)+lmax(rs));
	}
	void updatesame (int p,int d)
	{
	    sum(p)=d*siz(p),sam(p)=w(p)=ma(p)=d,laz2(p)=1;
	    if (d> 0) lmax(p)=rmax(p)=maxx(p)=sum(p);
	    else lmax(p)=rmax(p)=0,maxx(p)=d;
	}
	void updaterev (int p)
	{
	    laz1(p)^=1;
	    swap (son(p)[0],son(p)[1]),swap (lmax(p),rmax(p));
	}
	void push (int p)
	{
	    int ls=son(p)[0],rs=son(p)[1];
	    if (laz2(p))
	    {
		updatesame (ls,sam(p)),updatesame (rs,sam(p));
		ma(p)=sam(p);
		laz1(p)=laz2(p)=sam(p)=0;
	    }
	    if (laz1(p)) updaterev (ls),updaterev (rs),laz1(p)=0;
	}
	int build (int l,int r,int f)
	{
	    int mid=(l+r)>>1,p=add (tmp[mid],f);
	    if (l< mid) son(p)[0]=build (l,mid-1,p);
	    if (r> mid) son(p)[1]=build (mid+1,r,p);
	    update (p);
	    return p;
	}
	int get(int p) { return son(fa(p))[1]==p; }
	void rotate (int p)
	{
	    int f=fa(p),ff=fa(f),s=get(p);
	    son(f)[s]=son(p)[s^1];
	    if (son(f)[s]) fa(son(f)[s])=f;
	    son(p)[s^1]=f,fa(f)=p;
	    if (ff) son(ff)[son(ff)[1]==f]=p;
	    fa(p)=ff;
	    update (f),update (p);
	}
	void splay (int p,int to)
	{
	    while (fa(p)!=to)
	    {
		int f=fa(p),ff=fa(f);
		if (ff!=to)
		    rotate (get(p)==get(f)?f:p);
		rotate (p);
	    }
	    if (to==0) root=p;
	}
	int find (int p,int k)
	{
	    push (p);
	    int ls=son(p)[0],rs=son(p)[1];
	    if (siz(ls)+1==k) return p;
	    if (siz(ls)  >=k) return find (ls,k);
	    return find (rs,k-siz(ls)-1);
	}
	void insqujian (int l,int len)
	{
	    int x=find (root,l),y=find (root,l+1);
	    splay (x,0),splay (y,x);
	    son(y)[0]=build (1,len,y);
	    update (y),update (x);
	}
	void reverse (int l,int r)
	{
	    int x=find (root,l),y=find (root,r+2);
	    splay (x,0),splay (y,x);
	    int ls=son(y)[0];
	    laz1(ls)^=1;
	    swap (son(ls)[0],son(ls)[1]),swap (lmax(ls),rmax(ls));
	    update (y),update (x);
	}
	void collect (int p)
	{
	    if (!p) return ;
	    las[++las[0]]=p;
	    int ls=son(p)[0],rs=son(p)[1];
	    collect (ls),collect (rs);
	}
	void clear (int p)
	{
	    collect (p);
	    fa(p)=son(p)[0]=son(p)[1]=siz(p)=w(p)=laz1(p)=laz2(p)=sam(p)=sum(p)=maxx(p)=lmax(p)=rmax(p)=0;
	    ma(p)=-oo;
	}
	void del (int l,int r)
	{
	    int x=find (root,l),y=find (root,r+2);
	    splay (x,0),splay (y,x);
	    clear (son(y)[0]),son(y)[0]=0;
	    update (y),update (x);
	}
	int getsum (int l,int r)
	{
	    int x=find (root,l),y=find (root,r+2);
	    splay (x,0),splay (y,x);
	    return sum(son(y)[0]);
	}
	void makesame (int l,int r,int k)
	{
	    int x=find (root,l),y=find (root,r+2);
	    splay (x,0),splay (y,x);
	    updatesame (son(y)[0],k);
	    update (y),update (x);
	}
	int maxsum (int l,int r)
	{
	    int x=find (root,l),y=find (root,r+2);
	    splay (x,0),splay (y,x);
	    int ls=son(y)[0];
	    if (ma(ls)< 0) return ma(ls);
	    return maxx (ls);
	}
	int main()
	{
	    //freopen (".in","r",stdin);
	    //freopen (".out","w",stdout);
	    int n,m; sc(n),sc(m);
	    for (int i=1; i<=n; i++) sc(tmp[i]);
	    tmp[0]=tmp[n+1]=-oo/5;
	    for (int i=0; i<=n*2; i++)
		ma(i)=-oo;
	    root=build (0,n+1,0);
	    int num=n;
	    for (int i=1; i<=m; i++)
	    {
		char s[10]; scanf ("%s",s);
		if (s[2]=='X') { pr(maxsum (1,num)); continue; }
		int pos,tf; sc(pos),sc(tf);
		if (s[0]=='I')
		{
		    for (int j=1; j<=tf; j++) sc(tmp[j]);
		    insqujian (pos+1,tf);
		    num+=tf;
		}
		if (s[0]=='D') del (pos,pos+tf-1),num-=tf;
		if (s[2]=='K')
		{
		    int c; sc(c);
		    makesame (pos,pos+tf-1,c);
		}
		if (s[0]=='G') pr(getsum (pos,pos+tf-1));
		if (s[0]=='R') reverse (pos,pos+tf-1);
	    }

	    return 0;
	}

	
## Splay
``Splay``是一个看似高级的数据结构，然而本人并不很懂……
### 模板
#### 定义

	struct SPLAY
	{
		int fa,son[2],siz,laz1,laz2,sam,w;
		int sum,lmax,rmax,maxx,ma;
	}t[N]; int tot=0,root;
	#define fa(p) t[p].fa
	#define son(p) t[p].son
	#define siz(p) t[p].siz
	#define laz1(p) t[p].laz1
	#define laz2(p) t[p].laz2
	#define sam(p) t[p].sam
	#define w(p) t[p].w
	#define sum(p) t[p].sum
	#define lmax(p) t[p].lmax
	#define rmax(p) t[p].rmax
	#define maxx(p) t[p].maxx
	#define ma(p) t[p].ma
	int tmp[N],las[N];

#### 增加点

	int las[N];//储存删除后可重新使用的节点
	int add (int x,int f)
	{
		int p=las[0]?las[las[0]--]:++tot;
		fa(p)=f;
		son(p)[0]=son(p)[1]=laz1(p)=laz2(p)=sam(p)=0;
		siz(p)=1; w(p)=sum(p)=ma(p)=x;
		lmax(p)=rmax(p)=maxx(p)=max (x,0);
		return p;
	}

#### 各种更新
	
	void update (int p)
	{
		siz(p)=1; sum(p)=ma(p)=w(p);
		int ls=son(p)[0],rs=son(p)[1];
		siz(p)+=siz(ls)+siz(rs),sum(p)+=sum(ls)+sum(rs),ma(p)=max (ma(p),max(ma(ls),ma(rs)));
		lmax(p)=max (lmax(ls),max (sum(ls)+w(p),sum(ls)+w(p)+lmax(rs)));
		rmax(p)=max (rmax(rs),max (sum(rs)+w(p),sum(rs)+w(p)+rmax(ls)));
		maxx(p)=max (max (maxx(ls),maxx(rs)),rmax(ls)+w(p)+lmax(rs));
	}
	void updatesame (int p,int d)
	{
		sum(p)=d*siz(p),sam(p)=w(p)=ma(p)=d,laz2(p)=1;
		if (d> 0) lmax(p)=rmax(p)=maxx(p)=sum(p);
		else lmax(p)=rmax(p)=0,maxx(p)=d;
	}
	void updaterev (int p)
	{
		laz1(p)^=1;
		swap (son(p)[0],son(p)[1]),swap (lmax(p),rmax(p));
	}
	void push (int p)
	{
		int ls=son(p)[0],rs=son(p)[1];
		if (laz2(p))
		{
			updatesame (ls,sam(p)),updatesame (rs,sam(p));
			ma(p)=sam(p);
			laz1(p)=laz2(p)=sam(p)=0;
		}
		if (laz1(p)) updaterev (ls),updaterev (rs),laz1(p)=0;
	}

#### 建树

	int build (int l,int r,int f)
	{
		int mid=(l+r)>>1,p=add (tmp[mid],f);
		if (l< mid) son(p)[0]=build (l,mid-1,p);
		if (r> mid) son(p)[1]=build (mid+1,r,p);
		update (p);
		return p;
	}
	
#### 核心
	
	int get(int p) { return son(fa(p))[1]==p; }
	void rotate (int p)
	{
		int f=fa(p),ff=fa(f),s=get(p);
		son(f)[s]=son(p)[s^1];
		if (son(f)[s]) fa(son(f)[s])=f;
		son(p)[s^1]=f,fa(f)=p;
		if (ff) son(ff)[son(ff)[1]==f]=p;
		fa(p)=ff;
		update (f),update (p);
	}
	void splay (int p,int to)
	{
		while (fa(p)!=to)
		{
			int f=fa(p),ff=fa(f);
			if (ff!=to)
				rotate (get(p)==get(f)?f:p);
			rotate (p);
		}
		if (to==0) root=p;
	}
	int find (int p,int k)
	{
		push (p);
		int ls=son(p)[0],rs=son(p)[1];
		if (siz(ls)+1==k) return p;
		if (siz(ls)  >=k) return find (ls,k);
		return find (rs,k-siz(ls)-1);
	}
	
### 新增功能
不同操作有不同写法，但都有部分相同，栗：

	void collect (int p)//内存回收
	{
		if (!p) return ;
		las[++las[0]]=p;
		int ls=son(p)[0],rs=son(p)[1];
		collect (ls),collect (rs);
	}
	void clear (int p)//清除某棵子树
	{
		collect (p);
		fa(p)=son(p)[0]=son(p)[1]=siz(p)=w(p)=laz1(p)=laz2(p)=sam(p)=sum(p)=maxx(p)=lmax(p)=rmax(p)=ma(p)=0;
	}


	void ins (int l,int d)//单点插入
	{
		int x=find (root,l),y=find (root,l+1);
		splay (x,0),splay (y,x);
		son(y)[0]=add (d,y);
		update (y),update (x);
	}
	void change (int l,int d)//单点修改
	{
		int x=find (root,l+1);
		splay (x,0);
		w(x)=d;
		update (x);
	}
	void insqujian (int l,int len)//区间插入
	{
		int x=find (root,l),y=find (root,l+1);
		splay (x,0),splay (y,x);
		son(y)[0]=build (1,len,y);
		update (y),update (x);
	}
	void reverse (int l,int r)//区间翻转
	{
		int x=find (root,l),y=find (root,r+2);
		splay (x,0),splay (y,x);
		int ls=son(y)[0];
		laz1(ls)^=1;
		swap (son(ls)[0],son(ls)[1]),swap (lmax(ls),rmax(ls));
		update (y),update (x);
	}
	void del (int l,int r)//区间删除
	{
		int x=find (root,l),y=find (root,r+2);
		splay (x,0),splay (y,x);
		clear (son(y)[0]),son(y)[0]=0;
		update (y),update (x);
	}
	int getsum (int l,int r)//区间求和
	{
		int x=find (root,l),y=find (root,r+2);
		splay (x,0),splay (y,x);
		return sum(son(y)[0]);
	}
	void makesame (int l,int r,int k)//区间变为同一个数
	{
		int x=find (root,l),y=find (root,r+2);
		splay (x,0),splay (y,x);
		updatesame (son(y)[0],k);
		update (y),update (x);
	}
	int maxsum (int l,int r)//区间最大连续子段
	{
		int x=find (root,l),y=find (root,r+2);
		splay (x,0),splay (y,x);
		int ls=son(y)[0];
		if (ma(ls)< 0) return ma(ls);
		return maxx (ls);
	}

	
PS：想深入了解``Splay``，请去往其他``DUCK``佬的博客……

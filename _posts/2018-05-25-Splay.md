---
layout:     post
title:      "Splay"
subtitle:   ""
date:       2018-05-22
author:     "JU"
header-img: "img/post-bg-2015.jpg"
mathjax:    false
catalog:    true
tags:
    - 数据结构
---

### LuoguP3391

```c++

	#include <bits/stdc++.h>
	#define pr(p) printf("%d ",p)
	const int oo=2139063143;
	const int N=1010000;
	const int mod=1000000007;
	using namespace std;
	typedef long long LL;
	inline void sc (int &x)
	{
		x=0; static int p; p=1; static char c; c=getchar();
		while (!isdigit(c)) { if (c=='-') p=-1; c=getchar(); }
		while ( isdigit(c)) { x=(x<<1)+(x<<3)+(c-48); c=getchar(); }
		x*=p;
	}
	int n,m,tmp[N];
	struct SPLAY { int fa,son[2],siz,laz,w; }t[N]; int tot=0,root;
	#define fa(p) t[p].fa
	#define son(p) t[p].son
	#define siz(p) t[p].siz
	#define laz(p) t[p].laz
	#define w(p) t[p].w
	int add (int x,int f)
	{
		int p=++tot;
		fa(p)=f;
		son(p)[0]=son(p)[1]=0;
		siz(p)=1; w(p)=x;
		return p;
	}
	void update (int p)
	{
		siz(p)=1;
		int ls=son(p)[0],rs=son(p)[1];
		if (ls) siz(p)+=siz(ls);
		if (rs) siz(p)+=siz(rs);
	}
	void updaterev (int p)
	{
		laz(p)^=1;
		swap (son(p)[0],son(p)[1]);
	}
	void push (int p)
	{
		if (!laz(p)) return ;
		laz(p)^=1;
		updaterev (son(p)[0]),updaterev (son(p)[1]);
	}
	int build (int l,int r,int f)
	{
		int mid=(l+r)>>1,p=add (tmp[mid],f);
		if (l< mid) son(p)[0]=build (l,mid-1,p);
		if (r> mid) son(p)[1]=build (mid+1,r,p);
		update (p);
		return p;
	}
	int get (int p) { return son(fa(p))[1]==p; }
	void rotate (int p)
	{
		int f=fa(p),ff=fa(f),s=get(p);
		son(f)[s]=son(p)[s^1];
		if (son(f)[s]) fa(son(f)[s])=f;
		son(p)[s^1]=f,fa(f)=p;
		if (ff) son(ff)[son(ff)[1]==f]=p;
		fa(p)=ff;
		update (f),update (p);
	}
	void splay (int p,int to)
	{
		while (fa(p)!=to)
		{
			int f=fa(p),ff=fa(f);
			if (ff!=to)
				rotate (get(p)==get(f)?f:p);
			rotate (p);
		}
		if (to==0) root=p;
	}
	int find (int p,int k)
	{
		push (p);
		int ls=son(p)[0],rs=son(p)[1];
		if (siz(ls)+1==k) return p;
		if (siz(ls)  >=k) return find (ls,k);
		return find (rs,k-siz(ls)-1);
	}
	void reverse (int l,int r)
	{
		int x=find (root,l),y=find (root,r+2);
		splay (x,0),splay (y,x);
		int p=son(y)[0];
		laz(p)^=1;
		swap(son(p)[0],son(p)[1]);
		update (y),update (x);
	}
	void print (int p)
	{
		if (!p) return ;
		push (p);
		int ls=son(p)[0],rs=son(p)[1];
		print (ls);
		if (w(p)>=1&&w(p)<=n) pr(w(p));
		print (rs);
	}
	int main()
	{
		//freopen (".in","r",stdin);
		//freopen (".out","w",stdout);
		sc(n),sc(m);
		for (int i=1; i<=n; i++)
			tmp[i]=i;
		tmp[0]=tmp[n+1]=-oo/10;
		root=build (0,n+1,0);
		while (m--)
		{
			int l,r; sc(l),sc(r);
			reverse (l,r); 
		}
		print (root);
		return 0;
	}

```
### LuoguP2042

```c++

	#include <bits/stdc++.h>
	#define pr(p) printf("%d\n",p)
	const int oo=2139063143;
	const int N=1010000;
	const int mod=1000000007;
	using namespace std;
	typedef long long LL;
	inline void sc (int &x)
	{
		x=0; static int p; p=1; static char c; c=getchar();
		while (!isdigit(c)) { if (c=='-') p=-1; c=getchar(); }
		while ( isdigit(c)) { x=(x<<1)+(x<<3)+(c-48); c=getchar(); }
		x*=p;
	}
	struct SPLAY
	{
		int fa,son[2],siz,laz1,laz2,sam,w;
		int sum,lmax,rmax,maxx,ma;
	}t[N]; int tot=0,root;
	#define fa(p) t[p].fa
	#define son(p) t[p].son
	#define siz(p) t[p].siz
	#define laz1(p) t[p].laz1
	#define laz2(p) t[p].laz2
	#define sam(p) t[p].sam
	#define w(p) t[p].w
	#define sum(p) t[p].sum
	#define lmax(p) t[p].lmax
	#define rmax(p) t[p].rmax
	#define maxx(p) t[p].maxx
	#define ma(p) t[p].ma
	int tmp[N],las[N];
	int add (int x,int f)
	{
		int p=las[0]?las[las[0]--]:++tot;
		fa(p)=f;
		son(p)[0]=son(p)[1]=laz1(p)=laz2(p)=sam(p)=0;
		siz(p)=1; w(p)=sum(p)=ma(p)=x;
		lmax(p)=rmax(p)=maxx(p)=max (x,0);
		return p;
	}
	void update (int p)
	{
		siz(p)=1; sum(p)=ma(p)=w(p);
		int ls=son(p)[0],rs=son(p)[1];
		siz(p)+=siz(ls)+siz(rs),sum(p)+=sum(ls)+sum(rs),ma(p)=max (ma(p),max(ma(ls),ma(rs)));
		lmax(p)=max (lmax(ls),max (sum(ls)+w(p),sum(ls)+w(p)+lmax(rs)));
		rmax(p)=max (rmax(rs),max (sum(rs)+w(p),sum(rs)+w(p)+rmax(ls)));
		maxx(p)=max (max (maxx(ls),maxx(rs)),rmax(ls)+w(p)+lmax(rs));
	}
	void updatesame (int p,int d)
	{
		sum(p)=d*siz(p),sam(p)=w(p)=ma(p)=d,laz2(p)=1;
		if (d> 0) lmax(p)=rmax(p)=maxx(p)=sum(p);
		else lmax(p)=rmax(p)=0,maxx(p)=d;
	}
	void updaterev (int p)
	{
		laz1(p)^=1;
		swap (son(p)[0],son(p)[1]),swap (lmax(p),rmax(p));
	}
	void push (int p)
	{
		int ls=son(p)[0],rs=son(p)[1];
		if (laz2(p))
		{
			updatesame (ls,sam(p)),updatesame (rs,sam(p));
			ma(p)=sam(p);
			laz1(p)=laz2(p)=sam(p)=0;
		}
		if (laz1(p)) updaterev (ls),updaterev (rs),laz1(p)=0;
	}
	int build (int l,int r,int f)
	{
		int mid=(l+r)>>1,p=add (tmp[mid],f);
		if (l< mid) son(p)[0]=build (l,mid-1,p);
		if (r> mid) son(p)[1]=build (mid+1,r,p);
		update (p);
		return p;
	}
	int get(int p) { return son(fa(p))[1]==p; }
	void rotate (int p)
	{
		int f=fa(p),ff=fa(f),s=get(p);
		son(f)[s]=son(p)[s^1];
		if (son(f)[s]) fa(son(f)[s])=f;
		son(p)[s^1]=f,fa(f)=p;
		if (ff) son(ff)[son(ff)[1]==f]=p;
		fa(p)=ff;
		update (f),update (p);
	}
	void splay (int p,int to)
	{
		while (fa(p)!=to)
		{
			int f=fa(p),ff=fa(f);
			if (ff!=to)
				rotate (get(p)==get(f)?f:p);
			rotate (p);
		}
		if (to==0) root=p;
	}
	int find (int p,int k)
	{
		push (p);
		int ls=son(p)[0],rs=son(p)[1];
		if (siz(ls)+1==k) return p;
		if (siz(ls)  >=k) return find (ls,k);
		return find (rs,k-siz(ls)-1);
	}
	void insqujian (int l,int len)
	{
		int x=find (root,l),y=find (root,l+1);
		splay (x,0),splay (y,x);
		son(y)[0]=build (1,len,y);
		update (y),update (x);
	}
	void reverse (int l,int r)
	{
		int x=find (root,l),y=find (root,r+2);
		splay (x,0),splay (y,x);
		int ls=son(y)[0];
		laz1(ls)^=1;
		swap (son(ls)[0],son(ls)[1]),swap (lmax(ls),rmax(ls));
		update (y),update (x);
	}
	void collect (int p)
	{
		if (!p) return ;
		las[++las[0]]=p;
		int ls=son(p)[0],rs=son(p)[1];
		collect (ls),collect (rs);
	}
	void clear (int p)
	{
		collect (p);
		fa(p)=son(p)[0]=son(p)[1]=siz(p)=w(p)=laz1(p)=laz2(p)=sam(p)=sum(p)=maxx(p)=lmax(p)=rmax(p)=ma(p)=0;
	}
	void del (int l,int r)
	{
		int x=find (root,l),y=find (root,r+2);
		splay (x,0),splay (y,x);
		clear (son(y)[0]),son(y)[0]=0;
		update (y),update (x);
	}
	int getsum (int l,int r)
	{
		int x=find (root,l),y=find (root,r+2);
		splay (x,0),splay (y,x);
		return sum(son(y)[0]);
	}
	void makesame (int l,int r,int k)
	{
		int x=find (root,l),y=find (root,r+2);
		splay (x,0),splay (y,x);
		updatesame (son(y)[0],k);
		update (y),update (x);
	}
	int maxsum (int l,int r)
	{
		int x=find (root,l),y=find (root,r+2);
		splay (x,0),splay (y,x);
		int ls=son(y)[0];
		if (ma(ls)< 0) return ma(ls);
		return maxx (ls);
	}
	int main()
	{
		//freopen (".in","r",stdin);
		//freopen (".out","w",stdout);
		int n,m; sc(n),sc(m);
		for (int i=1; i<=n; i++) sc(tmp[i]);
		tmp[0]=tmp[n+1]=-oo/5;
		root=build (0,n+1,0);
		int num=n;
		for (int i=1; i<=m; i++)
		{
			char s[10]; scanf ("%s",s);
			if (s[2]=='X') { pr(maxsum (1,num)); continue; }
			int pos,tf; sc(pos),sc(tf);
			if (s[0]=='I')
			{
				for (int j=1; j<=tf; j++) sc(tmp[j]);
				insqujian (pos+1,tf);
				num+=tf;
			}
			if (s[0]=='D') del (pos,pos+tf-1),num-=tf;
			if (s[2]=='K')
			{
				int c; sc(c);
				makesame (pos,pos+tf-1,c);
			}
			if (s[0]=='G') pr(getsum (pos,pos+tf-1));
			if (s[0]=='R') reverse (pos,pos+tf-1);
		}

		return 0;
	}
```
	
## Splay
Splay是一个看似高级的数据结构，然而本人并不很懂……于是只能讲讲其功能的扩展。（以LuoguP2042为例）
### 模板
#### 定义
    struct SPLAY
    {
        int fa,son[2],size,lazy1,lazy2,sam,w;
        int sum,lmax,rmax,maxx,ma;
        #define fa(p) t[p].fa
        #define son(p) t[p].son
        #define size(p) t[p].size
        #define lazy1(p) t[p].lazy1
        #define lazy2(p) t[p].lazy2
        #define w(p) t[p].w
        #define sum(p) t[p].sum
        #define lmax(p) t[p].lmax
        #define rmax(p) t[p].rmax
        #define maxx(p) t[p].maxx
        #define sam(p) t[p].sam
        #define ma(p) t[p].ma
    }t[N]; int tot=0,root;
    int tmp[N];

#### 增加点
	
    int sur[N];//储存删除后可循环利用的节点编号
	int add (int x,int f)
	{
	    int p;
		if (sur[0]) p=sur[sur[0]--];
		else p=++tot;
	    fa(p)=f;
	    son(p)[0]=son(p)[1]=lazy1(p)=lazy2(p)=0;
	    size(p)=1; w(p)=sum(p)=ma(p)=x;
	    lmax(p)=rmax(p)=maxx(p)=max (x,0);
	    return p;
	}
	
#### 各种更新
	
    void update (int x)
    {
        if (!x) return ;
        size(x)=1; sum(x)=w(x);
        int ls=son(x)[0],rs=son(x)[1];
        ma(x)=w(x);
        if (ls) size(x)+=size(ls),sum(x)+=sum(ls),ma(x)=max(ma(x),ma(ls));
        if (rs) size(x)+=size(rs),sum(x)+=sum(rs),ma(x)=max(ma(x),ma(rs));
        lmax(x)=max (lmax(ls),max (sum(ls)+w(x),sum(ls)+w(x)+lmax(rs)));
        rmax(x)=max (rmax(rs),max (sum(rs)+w(x),sum(rs)+w(x)+rmax(ls)));
        maxx(x)=max (max (maxx(ls),maxx(rs)),rmax(ls)+w(x)+lmax(rs));
    }
    void update_same (int x,int k)
    {
        if (x) sum(x)=k*size(x),sam(x)=k,w(x)=k,lazy2(x)=1,ma(x)=k;
        if (k>0) lmax(x)=rmax(x)=maxx(x)=sum(x);
        else lmax(x)=rmax(x)=0,maxx(x)=k;
    }
    void update_rev (int x) { if (x) lazy1(x)^=1,swap (son(x)[0],son(x)[1]),swap (lmax(x),rmax(x)); }
    void push (int x)
    {
        if (!x) return ;
        if (lazy2(x))
        update_same (son(x)[0],sam(x)),update_same (son(x)[1],sam(x)),lazy2(x)=0,ma(x)=sam(x),sam(x)=0;
        if (lazy1(x)) update_rev (son(x)[0]),update_rev (son(x)[1]),lazy1(x)=0;
    }
	
#### 建树
	
    int build (int l,int r,int f)
    {
        int mid=(l+r)/2,tt;
        tt=add (tmp[mid],f);
        if (l<mid) son(tt)[0]=build (l,mid-1,tt);
        if (r>mid) son(tt)[1]=build (mid+1,r,tt);
        update (tt);
        return tt;
    }
	
#### 核心
	
    int get (int x) { return son(fa(x))[1]==x; }
    void rotate (int x)
    {
        int f=fa(x),ff=fa(f),son=get(x);
        son(f)[son]=son(x)[son^1];
        if (son(f)[son]) fa(son(f)[son])=f;
        son(x)[son^1]=f,fa(f)=x;
        if (ff) son(ff)[son(ff)[1]==f]=x;
        fa(x)=ff;
        update (f),update(x);
    }
    void splay (int x,int to)
    {
	while (fa(x)!=to)
	{
	    int f=fa(x),ff=fa(f);
	    if (ff!=to)
		rotate ( (get(x)==get(f)) ? f : x );
	    rotate (x);
	}
	if (to==0) root=x;
    }
    int rank (int k,int pos)
    {
        push (pos);
        if (size(son(pos)[0])+1==k) return pos;
        if (size(son(pos)[0])>=k) return rank (k,son(pos)[0]);
        else return rank (k-size(son(pos)[0])-1,son(pos)[1]);
    }
	
### 新增功能
不同操作有不同写法，但都有部分相同，栗：
#### 内存回收

	void coll (int x)
	{
		if (!x) return ;
		sur[++sur[0]]=x;
		coll (son(x)[0]),coll (son(x)[1]);
	}
	void clear (int x)
	{
	    coll (x);
	    fa(x)=son(x)[0]=son(x)[1]=w(x)=size(x)=lazy1(x)=lazy2(x)=lmax(x)=rmax(x)=maxx(x)=sam(x)=0;
	}
#### 删除

    void del (int l,int r)
    {
        int x=rank (l,root),y=rank (r+2,root);
        splay (x,0),splay (y,x);
        clear (son(y)[0]); son(y)[0]=0;
        update (y),update (x);
    }
    
#### 插入区间

    void insqujian (int l,int len)
    {
        int x=rank (l,root),y=rank (l+1,root);
        splay (x,0),splay (y,x);
        son(y)[0]=build (1,len,y);
        update (y),update (x);
    }
    
#### 区间翻转

    void rev (int l,int r)
    {
        int x=rank (l,root),y=rank(r+2,root);
        splay (x,0),splay (y,x);
        lazy1 (son(y)[0])^=1;
        swap (son(son(y)[0])[0],son(son(y)[0])[1]);
        swap (lmax(son(y)[0]),rmax(son(y)[0]));
        update (y),update (x);
    }
    
#### 查询

    int getsum (int l,int r)
    {
        int x=rank (l,root),y=rank (r+2,root);
        splay (x,0),splay (y,x);
        return sum(son(y)[0]);
    }
    int maxsum (int l,int r)
    {
        int x=rank (l,root),y=rank (r+2,root);
        splay (x,0),splay (y,x);
        if (ma(son(y)[0])<0) return ma(son(y)[0]);
        return maxx(son(y)[0]);
    }
    
## 总结
观察一番可知，功能函数的写法通常为：

	int/void XXX (int l,int r,……)
	{
		int x=rank (l,root),y=rank (r+2,root);
		//插入区间略有不同，int x=rank (l,root),y=rank (l+1,root);
		splay (x,0),splay (y,x);
		//操作/查询，都在son(y)[0]处进行
		//若为操作，则应update (y),update (x);
	}
	
PS：想深入了解Splay，请去往其他DUCK佬的博客……

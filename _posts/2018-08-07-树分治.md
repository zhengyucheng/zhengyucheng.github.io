---
layout:     post
title:      "树分治"
subtitle:   "抽象"
date:       2018-08-07
author:     "JU"
header-img: "img/post-bg-2015.jpg"
mathjax:    true
catalog:    true
tags:
    - 树
---
### Luogu3806

    #include <cstdio>
    #include <cstring>
    #include <cstdlib>
    #include <cmath>
    #include <algorithm>
    #include <iostream>
    #include <set>
    #define sc(p) scanf("%d",&p)
    #define sc2(p1,p2) sc(p1),sc(p2)
    #define sc3(p1,p2,p3) sc2(p1,p2),sc(p3)
    #define pr(p) printf("%d\n",p)
    const int oo=2147483640;
    const int N=2010000;
    using namespace std;
    inline void read (int &x)
    {
        x=0; static int p; p=1; static char c; c=getchar();
        while (!isdigit(c)) { if (c=='-') p=-1; c=getchar(); }
        while ( isdigit(c)) { x=(x<<1)+(x<<3)+(c-48); c=getchar(); }
        x*=p;
    }
    struct EDGE { int v,nx,len; }lb[N]; int tot=1,top[N];
    void add (int u,int v,int len) { lb[++tot].v=v,lb[tot].len=len,lb[tot].nx=top[u],top[u]=tot; }
    int siz[N],masiz[N];
    bool vis[N];
    int que[N],head,tail;
    void getroot (int u)
    {
        vis[u]=1,masiz[u]=0,siz[u]=1;
        que[tail++]=u;
        for (int kb=top[u]; kb!=-1; kb=lb[kb].nx)
        {
            int v=lb[kb].v;
            if (vis[v]) continue;
            getroot (v);
            siz[u]+=siz[v];
            masiz[u]=max (masiz[u],siz[v]);
        }
        vis[u]=0;
    }
    int n,kk,x[N]; bool t[N];
    int dep[N],id[N];
    set <int> s;
    void calc (int u,int fa,int w)
    {
        for (int i=1; i<=kk; i++) if (!t[i])
        if (s.find (x[i]-w)!=s.end()) t[i]=1;
        for (int kb=top[u]; kb!=-1; kb=lb[kb].nx)
        {
            int v=lb[kb].v;
            if (vis[v]||v==fa) continue;
            calc (v,u,w+lb[kb].len);
        }
    }
    void update (int u,int fa,int w)
    {
        s.insert (w);
        for (int kb=top[u]; kb!=-1; kb=lb[kb].nx)
        {
            int v=lb[kb].v;
            if (vis[v]||v==fa) continue;
            update (v,u,w+lb[kb].len);
        }
    }
    void work (int u)
    {
        head=tail=0;
        getroot (u);
        int tt=siz[u],mi=masiz[u];
        for (int i=0; i<tail; i++)
        {
            int y=que[i];
            int m=max (masiz[y],tt-masiz[y]);
            if (m<mi) mi=m,u=y;
        }
        s.insert (0);
        vis[u]=1;
        for (int kb=top[u]; kb!=-1; kb=lb[kb].nx)
        {
            int v=lb[kb].v;
            if (vis[v]) continue;
            calc (v,u,lb[kb].len);
            update (v,u,lb[kb].len);
        }
        s.clear();
        for (int kb=top[u]; kb!=-1; kb=lb[kb].nx)
        {
            int v=lb[kb].v;
            if (vis[v]) continue;
            work(v);
        }
    }
    int main()
    {
        //freopen(".in","r",stdin);
        //freopen(".out","w",stdout);
        read(n),read(kk);
        memset (top,-1,sizeof (top));
        int u,v,l;
        for (int i=1; i< n; i++)
        read(u),read(v),read(l),add (u,v,l),add (v,u,l);
        for (int i=1; i<=kk; i++) read(x[i]);
        work (1);
        for (int i=1; i<=kk; i++)
        if (t[i]||!x[i]) puts("AYE");
        else puts("NAY");
        return 0;
    }
    
### POJ1741

    #include <cstdio>
    #include <cstring>
    #include <cstdlib>
    #include <cmath>
    #include <algorithm>
    #include <iostream>
    #define sc(p) scanf("%d",&p)
    #define sc2(p1,p2) sc(p1),sc(p2)
    #define sc3(p1,p2,p3) sc2(p1,p2),sc(p3)
    #define pr(p) printf("%d\n",p)
    const int oo=2147483640;
    const int N=10100;
    using namespace std;
    struct EDGE { int v,nx,len; }lb[N<<1]; int top[N],tot=1;
    void add (int u,int v,int len) { lb[++tot].v=v,lb[tot].len=len,lb[tot].nx=top[u],top[u]=tot; }
    int q[N],head,tail;
    int siz[N],vis[N],masiz[N],dep[N];
    int n,k;
    bool ly (int A,int B) { return dep[A]<dep[B]; }
    void dfs (int x)
    {
        siz[x]=vis[x]=1,masiz[x]=0;
        q[tail++]=x;
        for (int kb=top[x]; kb!=-1; kb=lb[kb].nx)
        {
            int v=lb[kb].v;
            if (vis[v]) continue;
            dep[v]=dep[x]+lb[kb].len;
            dfs (v);
            siz[x]+=siz[v];
            masiz[x]=max (masiz[x],siz[v]);
        }
        vis[x]=0;
    }
    int calc (int l,int r)
    {
        sort (q+l,q+r,ly);
        int ans=0;
        for (int i=l,j=r-1; i<j; i++)
        {
            while (j>i&&dep[q[j]]+dep[q[i]]>k) j--;
            ans+=j-i;
        }
        return ans;
    }
    int work (int x)
    {
        head=tail=0;
        dfs (x);
        int t=siz[x],mi=masiz[x];
        for (int i=0; i<tail; i++)
        {
            int y=q[i];
            int m=max (masiz[y],t-siz[y]);
            if (m<mi) mi=m,x=y;
        }

        vis[x]=1;
        int ans=0;
        head=tail=0;
        for (int kb=top[x]; kb!=-1; kb=lb[kb].nx)
        {
            int y=lb[kb].v;
            if (vis[y]) continue;
            dep[y]=lb[kb].len; dfs(y);
            ans-=calc (head,tail);
            head=tail;//小技巧：每次更改队列开头，可以保留之前dfs结果
        }

        dep[x]=0,q[tail++]=x;
        ans+=calc (0,tail);

        for (int kb=top[x]; kb!=-1; kb=lb[kb].nx)
        {
            int y=lb[kb].v;
            if (!vis[y]) ans+=work(y);
        }
        return ans;
    }
    int main()
    {
        while (sc2(n,k)!=EOF)
        {
            if (n==0) break;
            memset (vis,0,sizeof (vis));
            memset (lb ,0,sizeof (lb )); tot=1;
            memset (top,-1,sizeof (top));
            for (int i=1; i< n; i++)
            {
                int u,v,len; sc3(u,v,len);
                add (u,v,len),add(v,u,len);
            }
            pr(work (1));
        }
        return 0;
    }
    
## 树分治
### 引入
给出特定条件，问整棵树有多少满足条件的路径。  
如：给出一个值`K`，问整棵树有多少长度在`K`以内的路径。 
## 点分治
将树上的路径分为两类，通过树根的，和不通过树根的。  
通过树根的，路径的两端一定在两棵子树中，反之两端则在同一棵子树中。
仅需解决第一种情况，第二种可以递归处理。
### 方法
暴力。  
DFS出每一个点到根的距离，$O(n)$。  
然后算出有多少对点的距离总和小于等于`K`。  
当然，结果有一些不合法，比如两个点都在同一棵子树中，这些需要另外计算减掉。  
但是，若子树大小减小得太慢，会退化成$O(n^2)$。  
因此，要找到一个合适的根（重心），使最大子树的大小最小（小于一半）。  
每次大小减半，$O(n\log_{}{n})$。  
### 找重心
解决以x为根的子树重心：

    void dfs (int x)
    {
        siz[x]=vis[x]=1,masiz[x]=0;
        q[tail++]=x;
        for (int kb=top[x]; kb!=-1; kb=lb[kb].nx)
        {
            int v=lb[kb].v;
            if (vis[v]) continue;
            dep[v]=dep[x]+lb[kb].len;
            dfs (v);
            siz[x]+=siz[v];
            masiz[x]=max (masiz[x],siz[v]);
        }
        vis[x]=0;
    }//用vis隔开不同的分治层次，之后`dfs`时就不会越过这个点。
    
    head=tail=0;
    dfs (x);
    int t=siz[x],mi=masiz[x];
    for (int i=0; i<tail; i++)
    {
        int y=q[i];
        int m=max (masiz[y],t-siz[y]);
        if (m<mi) mi=m,x=y;
    }

#### 处理通过重心路径
如果一条路径穿过重心，那么两端在不同的子树中。  
每访问一棵子树，就把它的信息记录下来。  
当访问新的子树的时候，和已经访问的子树的节点之间两两配对。  
这样可以保证每一对端点都在两棵不同的子树中，而且只会算一次。  
栗：条件为路径长度`≤K`，当前点到重心距离为L，算出有多少点到重心距离小于等于`K-L`即可。  
数据结构可解决（树状数组）。  
或排序后从两端各设指针相向移动。

    int calc (int l,int r)
    {
        sort (q+l,q+r,ly);
        int ans=0;
        for (int i=l,j=r-1; i<j; i++)
        {
            while (j>i&&dep[q[j]]+dep[q[i]]>k) j--;
            ans+=j-i;
        }
        return ans;
    }
    
#### 更改与清除
不能用memset，会变$O(n^2)$。
清除时，应逐个撤销修改。

## 边分治
[ ![边分治](/img/边分治.png) ](/img/边分治.png)
## 点分治树与边分治树
[ ![点分治树与边分治树](/img/点分治树与边分治树.png) ](/img/点分治树与边分治树.png)
# %%%LZZ
